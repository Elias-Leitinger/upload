{name="promise",version="0.7",checksums={["/usr/lib/promise.lua"]="¸Ä­Ëlš]”\5^K^,€\11\0034Uª\29«<´H\0173TÑ\27#µÁ"},files={["/usr/lib/promise.lua"]="local uuid = require(\"uuid\")\13\nlocal oop = require(\"oop\")\13\nlocal event = require(\"event\")\13\n\13\n-- Workaround for a bug in OpenOS 1.7.1 on Lua 5.3 mode.\13\n-- Hopefully this will be removed some day...\13\n_G.bit32 = require(\"bit32\")\13\n\13\nlocal promise = {\13\n\9uuid_ = nil,\13\n\9onCompletionCallbacks_ = {},\13\n\9onFailureCallbacks_ = {},\13\n\9onFinallyCallbacks_ = {},\13\n\9retvalCompleted_ = nil,\13\n\9retvalFailed_ = nil,\13\n\9thread_ = nil,\13\n\9running_ = false\13\n}\13\noop.make(promise)\13\n\13\nfunction promise:construct(taskProc, ...)\13\n\9self.uuid_ = uuid.next()\13\n\9self.running_ = true\13\n\9self:launchWorker(taskProc, ...)\13\nend\13\n\13\n-- Private methods\13\n\13\nfunction promise:launchWorker(taskProc, ...)\13\n\9local this = self\13\n\9local args = table.pack(...)\13\n\13\n\9self.thread_ = event.timer(0, function()\13\n\9\9this:workerProc(taskProc, table.unpack(args))\13\n\9end, 1)\13\n\9--thread.create(promise.workerProc, self, taskProc, ...)\13\nend\13\n\13\nfunction promise:workerProc(taskProc, ...)\13\n\9local retval = table.pack(xpcall(taskProc, function(...)\13\n\9\9self.retvalFailed_ = table.pack(...)\13\n\9\9self:onFailure(...)\13\n\9end, ...))\13\n\13\n\9-- If retval[1] is false, then the error handler has already been called.\13\n\9if retval[1] then\13\n\9\9-- The first value is the success indicator from xpcall. Remove it!\13\n\9\9table.remove(retval, 1)\13\n\9\9self.retvalCompleted_ = retval\13\n\9\9self:onComplete(table.unpack(retval))\13\n\9end\13\nend\13\n\13\nfunction promise:onComplete(...)\13\n\9if #self.onCompletionCallbacks_ == 0 then\13\n\9\9self:onFinally()\13\n\9else\13\n\9\9local next_task = table.remove(self.onCompletionCallbacks_, 1)\13\n\9\9self:launchWorker(next_task, ...)\13\n\9end\13\nend\13\n\13\nfunction promise:onFailure(...)\13\n\9for _, callback in pairs(self.onFailureCallbacks_) do\13\n\9\9xpcall(callback, function(...)\13\n\9\9\9io.stderr:write(\"[promise \" .. self.uuid_ .. \"] Error in failure handler\\n\" .. debug.traceback( ... ) .. \"\\n\")\13\n\9\9end, ...)\13\n\9end\13\n\13\n\9if #self.onFailureCallbacks_ == 0 then\13\n\9\9io.stderr:write(\"[promise \" .. self.uuid_ .. \"] \" .. debug.traceback( ... ) .. \"\\n\")\13\n\9end\13\n\13\n\9self:onFinally()\13\nend\13\n\13\nfunction promise:onFinally()\13\n\9for _, callback in pairs(self.onFinallyCallbacks_) do\13\n\9\9xpcall(callback, function(...)\13\n\9\9\9io.stderr:write(\"[promise \" .. self.uuid_ .. \"] Error in finally handler\\n\" .. debug.traceback( ... ) .. \"\\n\")\13\n\9\9end)\13\n\9end\13\n\9self.running_ = false\13\nend\13\n\13\n-- Public methods\13\n\13\nfunction promise:after(callback, ...)\13\n\9checkArg(1, callback, \"function\")\13\n\13\n\9local args = table.pack(...)\13\n\13\n\9if self.running_ then\13\n\9\9table.insert(self.onCompletionCallbacks_, function(...)\13\n\9\9\9if #args > 0 then\13\n\9\9\9\9return callback(table.unpack(args), ...)\13\n\9\9\9else\13\n\9\9\9\9return callback(...)\13\n\9\9\9end\13\n\9\9end)\13\n\9elseif self.retvalCompleted_ == nil then\13\n\9\9-- Guess we failed...\13\n\9elseif #args > 0 then\13\n\9\9self:launchWorker(callback, ..., table.unpack(self.retvalCompleted_))\13\n\9else\13\n\9\9self:launchWorker(callback, table.unpack(self.retvalCompleted_))\13\n\9end\13\n\13\n\9return self\13\nend\13\n\13\nfunction promise:catch(callback, ...)\13\n\9checkArg(1, callback, \"function\")\13\n\13\n\9local this = self\13\n\9local args = table.pack(...)\13\n\13\n\9if self.retvalFailed_ == nil then\13\n\9\9table.insert(self.onFailureCallbacks_, function(...)\13\n\9\9\9if #args > 0 then\13\n\9\9\9\9return callback(table.unpack(args), ...)\13\n\9\9\9else\13\n\9\9\9\9return callback(...)\13\n\9\9\9end\13\n\9\9end)\13\n\9elseif #args > 0 then\13\n\9\9xpcall(callback, function(...)\13\n\9\9\9io.stderr:write(\"[promise \" .. this.uuid_ .. \"] Error in failure handler\\n\" .. debug.traceback( ... ) .. \"\\n\")\13\n\9\9end, ..., table.unpack(self.retvalFailed_))\13\n\9else\13\n\9\9xpcall(callback, function(...)\13\n\9\9\9io.stderr:write(\"[promise \" .. this.uuid_ .. \"] Error in failure handler\\n\" .. debug.traceback( ... ) .. \"\\n\")\13\n\9\9end, table.unpack(self.retvalFailed_))\13\n\9end\13\n\13\n\9return self\13\nend\13\n\13\nfunction promise:finally(callback, ...)\13\n\9checkArg(1, callback, \"function\")\13\n\13\n\9local this = self\13\n\9local args = table.pack(...)\13\n\13\n\9if self.retvalCompleted_ == nil and self.retvalFailed_ == nil then\13\n\9\9table.insert(self.onFinallyCallbacks_, function()\13\n\9\9\9return callback(table.unpack(args))\13\n\9\9end)\13\n\9else\13\n\9\9xpcall(callback, function(...)\13\n\9\9\9io.stderr:write(\"[promise \" .. this.uuid_ .. \"] Error in finally handler\\n\" .. debug.traceback( ... ) .. \"\\n\")\13\n\9\9end, ...)\13\n\9end\13\n\13\n\9return self\13\nend\13\n\13\nfunction promise:wait()\13\n\9while self.running_ and self.thread_ ~= nil do\13\n\9\9os.sleep(0.05)\13\n\9end\13\nend\13\n\13\nreturn promise\13\n"},links={},depends={"oop"}}