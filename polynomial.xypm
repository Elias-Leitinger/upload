{checksums={["/usr/lib/polynomial.lua"]="çp\22•8o‡[\19•\14R©2×zºçüËèQëkuðÝŽ!\11Û",["/usr/lib/polynomial_iterpolator.lua"]="oªL\14\18\20\0093Ì›Ø(uäR\11ÎöÙ1\14Ìƒ\3¢\24D+‚\1"},files={["/usr/lib/polynomial_iterpolator.lua"]="local polynomial = require(\"polynomial\")\13\nlocal matrix = require(\"matrix\")\13\n\13\nlocal polynomial_interpolator = {\13\n}\13\n\13\nlocal function QRstep(A, E, step)\13\n\9local v = A:extractC(step)\13\n\9for i=0, step-1 do\13\n\9\9v:set(i, 0, 0)\13\n\9end\13\n\9local u = E:extractC(step):multI(v:norm()):add(v)\13\n\9local H = E:sub(u:mult(u:transponate()):multI( 2.0 / u:transponate():mult(u):get(0,0) ))\13\n\9local As = H:mult(A)\13\n\9return { H = H, As = As }\13\nend\13\n\13\nlocal function QRsolve(As, x)\13\n\9local dimension = As.columns - 1\13\n\9local coefs = {}\13\n\13\n\9for i=0, dimension do\13\n\9\9table.insert(coefs, 0)\13\n\9end\13\n\13\n\9for i2=0, dimension do\13\n\9\9local i = dimension - i2\13\n\9\9local x = x:get(i, 0)\13\n\13\n\9\9for j=i+1, dimension do\13\n\9\9\9x = x - coefs[1 + j] * As:get(i, j)\13\n\9\9end\13\n\9\9coefs[1 + i] = x / As:get(i,i)\13\n\9end\13\n\13\n\9return coefs\13\nend\13\n\13\nfunction polynomial_interpolator.interpolate(data, dimension)\13\n\9assert(#data >= dimension+1, \"Not enough data provided to interpolate a polynom of the desired dimension\")\13\n\13\n\9local E = matrix.makeE(#data, #data)\13\n\9local A = matrix.make(#data, dimension+1)\13\n\9local b = matrix.make(#data, 1)\13\n\13\n\9for i=0, #data-1 do\13\n\9\9for j=0, dimension do\13\n\9\9\9A:set(i, j, math.pow(data[i+1][1], j))\13\n\9\9end\13\n\9\9b:set(i, 0, data[i+1][2])\13\n\9end\13\n\13\n\9local ip = QRstep(A, E, 0)\13\n\9local Q = ip.H\13\n\9for i=1, dimension do\13\n\9\9ip = QRstep(ip.As, E, i)\13\n\9\9Q = Q:mult(ip.H)\13\n\9end\13\n\13\n\9local x = Q:transponate():mult(b)\13\n\13\n\9local coefs = QRsolve(ip.As, x)\13\n\9return polynomial.make(coefs)\13\nend\13\n\13\nsetmetatable(polynomial_interpolator, {\13\n\9__call = polynomial_interpolator.interpolate\13\n})\13\n\13\nreturn polynomial_interpolator",["/usr/lib/polynomial.lua"]="local polynomial = {\13\n\9coefs = nil\13\n}\13\n\13\nfunction polynomial.make(coefs)\13\n\9local new_polynomial = {\13\n\9\9coefs = {}\13\n\9}\13\n\13\n\9for _, coef in pairs(coefs) do\13\n\9\9table.insert(new_polynomial.coefs, coef)\13\n\9end\13\n\13\n\9setmetatable(new_polynomial, {\13\n\9\9__index = polynomial\13\n\9})\13\n\9return new_polynomial\13\nend\13\n\13\nfunction polynomial.eval(polynomial, x)\13\n\9local fx = 0\13\n\9local x2 = 1\13\n\9for i, coef in pairs(polynomial.coefs) do\13\n\9\9fx = fx + coef*x2\13\n\9\9x2 = x2 * x\13\n\9end\13\n\9return fx\13\nend\13\n\13\nfunction polynomial.derivate(polynomial)\13\n\9local new_coefs = {}\13\n\9for i=2, #polynomial.coefs do\13\n\9\9table.insert(new_coefs, (i-1)*polynomial.coefs[i])\13\n\9end\13\n\9return polynomial.make(new_coefs)\13\nend\13\n\13\nfunction polynomial.toString(polynomial)\13\n\9local str = \"0\"\13\n\9for i, coef in pairs(polynomial.coefs) do\13\n\9\9if i > 1 then\13\n\9\9\9if coef > 0 then\13\n\9\9\9\9str = str .. \" + \" .. string.format(\"%f\", coef) .. \" x^\" .. tostring(i-1)\13\n\9\9\9elseif coef < 0 then\13\n\9\9\9\9str = str .. \" - \" .. string.format(\"%f\", -coef) .. \" x^\" .. tostring(i-1)\13\n\9\9\9end\13\n\9\9else\13\n\9\9\9str = string.format(\"%f\", coef)\13\n\9\9end\13\n\9end\13\n\9return str\13\nend\13\n\13\nfunction polynomial.converge(polynomial, x, iterations)\13\n\9local df1 = polynomial:derivate()\13\n\9local df2 = df1:derivate()\13\n\13\n\9for i=1, iterations do\13\n\9\9x = x - df1:eval(x) / df2:eval(x)\13\n\9end\13\n\9return x\13\nend\13\n\13\nreturn polynomial",["/usr/lib/matrix.lua"]="local matrix_proto = {\13\n\9columns = nil,\13\n\9rows = nil,\13\n\9data = nil\13\n}\13\n\13\n\13\nfunction matrix_proto.make(rows, columns)\13\n\9assert(tonumber(rows) ~= nil, \"rows needs to be a number\")\13\n\9assert(tonumber(columns) ~= nil, \"columns needs to be a number\")\13\n\9assert(rows > 0 and columns > 0, \"Invalid dimension for matrix: \" .. tostring(rows) ..\"x\" .. tostring(columns))\13\n\13\n\9local new_matrix = {\13\n\9\9rows = rows,\13\n\9\9columns = columns,\13\n\9\9data = {}\13\n\9}\13\n\13\n\9for _=1, (rows*columns) do\13\n\9\9table.insert(new_matrix.data, 0)\13\n\9end\13\n\13\n\9setmetatable(new_matrix, {\13\n\9\9__index = matrix_proto\13\n\9})\13\n\9return new_matrix\13\nend\13\n\13\nfunction matrix_proto.duplicate(matrix)\13\n\9local new_matrix = {\13\n\9\9rows = matrix.rows,\13\n\9\9columns = matrix.columns,\13\n\9\9data = {}\13\n\9}\13\n\13\n\9setmetatable(new_matrix, {\13\n\9\9__index = matrix_proto\13\n\9})\13\n\13\n\9setmetatable(new_matrix.data, {\13\n\9\9__index = matrix.data\13\n\9})\13\n\9return new_matrix\13\nend\13\n\13\nfunction matrix_proto.makeE(rows, columns)\13\n\9local result = matrix_proto.make(rows, columns)\13\n\13\n\9for i=0, math.min(rows, columns)-1 do\13\n\9\9result:set(i, i, 1)\13\n\9end\13\n\9return result\13\nend\13\n\13\nfunction matrix_proto.set(matrix, row, column, value)\13\n\9assert(tonumber(row) ~= nil, \"row needs to be a number\")\13\n\9assert(tonumber(column) ~= nil, \"column needs to be a number\")\13\n\9assert(tonumber(value) ~= nil, \"value needs to be a number\")\13\n\9assert(row < matrix.rows and column < matrix.columns, \"Tried to access cell [\" .. tostring(row) ..\"][\" .. tostring(column) .. \"] of matrix \" .. tostring(matrix) .. \" with dimension \" .. tostring(matrix.rows) .. \"x\" .. tostring(matrix.columns))\13\n\13\n\9matrix.data[1 + column*matrix.rows + row] = tonumber(value);\13\nend\13\n\13\nfunction matrix_proto.setT(matrix, row, column, value)\13\n\9assert(tonumber(row) ~= nil, \"row needs to be a number\")\13\n\9assert(tonumber(column) ~= nil, \"column needs to be a number\")\13\n\9assert(tonumber(value) ~= nil, \"value needs to be a number\")\13\n\9assert(row < matrix.rows and column < matrix.columns, \"Tried to access cell [\" .. tostring(row) ..\"][\" .. tostring(column) .. \"] of matrix \" .. tostring(matrix) .. \" with dimension \" .. tostring(matrix.rows) .. \"x\" .. tostring(matrix.columns))\13\n\13\n\9matrix.data[1 + column + row*matrix.columns] = tonumber(value);\13\nend\13\n\13\nfunction matrix_proto.get(matrix, row, column)\13\n\9assert(tonumber(row) ~= nil, \"row needs to be a number\")\13\n\9assert(tonumber(column) ~= nil, \"column needs to be a number\")\13\n\9assert(row < matrix.rows and column < matrix.columns, \"Tried to access cell [\" .. tostring(row) ..\"][\" .. tostring(column) .. \"] of matrix \" .. tostring(matrix) .. \" with dimension \" .. tostring(matrix.rows) .. \"x\" .. tostring(matrix.columns))\13\n\13\n\9return matrix.data[1 + column*matrix.rows + row];\13\nend\13\n\13\nfunction matrix_proto.getT(matrix, row, column)\13\n\9assert(tonumber(row) ~= nil, \"row needs to be a number\")\13\n\9assert(tonumber(column) ~= nil, \"column needs to be a number\")\13\n\9assert(row < matrix.rows and column < matrix.columns, \"Tried to access cell [\" .. tostring(row) ..\"][\" .. tostring(column) .. \"] of matrix \" .. tostring(matrix) .. \" with dimension \" .. tostring(matrix.rows) .. \"x\" .. tostring(matrix.columns))\13\n\13\n\9return matrix.data[1 + column + row*matrix.columns];\13\nend\13\n\13\nfunction matrix_proto.extractC(matrix, column)\13\n\9assert(tonumber(column) ~= nil, \"column needs to be a number\")\13\n\13\n\9local result = matrix.make(matrix.rows, 1)\13\n\9for row=0, matrix.rows-1 do\13\n\9\9result:set(row, 0, matrix:get(row, column))\13\n\9end\13\n\9return result\13\nend\13\n\13\nfunction matrix_proto.sub(matrixA, matrixB)\13\n\9assert(matrixA.rows == matrixB.rows and matrixA.columns == matrixB.columns, \"Tried to substract two incompatible matrices: LHS has dimension \" .. tostring(matrixA.rows) .. \"x\" .. tostring(matrixA.columns) .. \", RHS has dimension \" .. tostring(matrixB.rows) .. \"x\" .. tostring(matrixB.columns))\13\n\9local result = matrix_proto.make(matrixA.rows, matrixA.columns)\13\n\13\n\9for column=0, matrixB.columns-1 do\13\n\9\9for row=0, matrixA.rows-1 do\13\n\9\9\9result:set(row, column, matrixA:get(row, column) - matrixB:get(row, column))\13\n\9\9end\13\n\9end\13\n\9return result\13\nend\13\n\13\nfunction matrix_proto.add(matrixA, matrixB)\13\n\9assert(matrixA.rows == matrixB.rows and matrixA.columns == matrixB.columns, \"Tried to add two incompatible matrices: LHS has dimension \" .. tostring(matrixA.rows) .. \"x\" .. tostring(matrixA.columns) .. \", RHS has dimension \" .. tostring(matrixB.rows) .. \"x\" .. tostring(matrixB.columns))\13\n\9local result = matrix_proto.make(matrixA.rows, matrixA.columns)\13\n\13\n\9for column=0, matrixB.columns-1 do\13\n\9\9for row=0, matrixA.rows-1 do\13\n\9\9\9result:set(row, column, matrixA:get(row, column) + matrixB:get(row, column))\13\n\9\9end\13\n\9end\13\n\9return result\13\nend\13\n\13\nfunction matrix_proto.mult(matrixA, matrixB)\13\n\9assert(matrixA.columns == matrixB.rows, \"Tried to multiply two incompatible matrices: LHS has dimension \" .. tostring(matrixA.rows) .. \"x\" .. tostring(matrixA.columns) .. \", RHS has dimension \" .. tostring(matrixB.rows) .. \"x\" .. tostring(matrixB.columns))\13\n\9local result = matrix_proto.make(matrixA.rows, matrixB.columns)\13\n\13\n\9for column=0, matrixB.columns-1 do\13\n\9\9for row=0, matrixA.rows-1 do\13\n\9\9\9local cell_value = 0\13\n\9\9\9for i=0, matrixA.columns-1 do\13\n\9\9\9\9cell_value = cell_value + matrixA:get(row, i) * matrixB:get(i, column)\13\n\9\9\9end\13\n\9\9\9result:set(row, column, cell_value)\13\n\9\9end\13\n\9end\13\n\9return result\13\nend\13\n\13\nfunction matrix_proto.multI(matrix, mult)\13\n\9assert(tonumber(mult) ~= nil, \"mult needs to be a number\")\13\n\9local result = matrix_proto.make(matrix.rows, matrix.columns)\13\n\13\n\9for i=1,(matrix.rows*matrix.columns) do\13\n\9\9result.data[i] = mult * matrix.data[i]\13\n\9end\13\n\9return result\13\nend\13\n\13\nfunction matrix_proto.transponate(matrix)\13\n\9local result = matrix:duplicate()\13\n\9local tmp\13\n\13\n\9tmp = result.columns\13\n\9result.columns = result.rows\13\n\9result.rows = tmp\13\n\13\n\9tmp = result.set\13\n\9result.set = result.setT\13\n\9result.setT = tmp\13\n\13\n\9tmp = result.get\13\n\9result.get = result.getT\13\n\9result.getT = tmp\13\n\13\n\9return result\13\nend\13\n\13\nfunction matrix_proto.norm(matrix, norm)\13\n\9if norm == nil then\13\n\9\9norm = 2\13\n\9end\13\n\13\n\9local tmp = 0\13\n\9for i=1,(matrix.rows*matrix.columns) do\13\n\9\9tmp = tmp + math.pow(matrix.data[i], norm)\13\n\9end\13\n\9return math.pow(tmp, 1/norm)\13\nend\13\n\13\nfunction matrix_proto.dump(matrix)\13\n\9print(tostring(matrix.rows) .. \"x\" .. tostring(matrix.columns))\13\n\9for row=0, matrix.rows-1 do\13\n\9\9local str = nil\13\n\9\9for column=0, matrix.columns-1 do\13\n\9\9\9if str ~= nil then\13\n\9\9\9\9str = str .. string.format(\" % 10.6f\", matrix:get(row, column))\13\n\9\9\9else\13\n\9\9\9\9str = string.format(\"% 10.6f\", matrix:get(row, column))\13\n\9\9\9end\13\n\9\9end\13\n\9\9print(str)\13\n\9end\13\nend\13\n\13\n\13\nreturn matrix_proto\13\n"},name="polynomial",links={},version="1.3"}