{checksums={["/etc/rc.d/brgc_turbine.lua"]="WIy\20Óu0ﬁã˜óŸ¬J∂ìo\7ÛRóÃªî…gû\24ÇAÖL",["/etc/rc.d/brgc_grid.lua"]="˛wœ»ÌzË‹Úé@xüõáù€)8<UŒÜÊı\"Õ\12?N‘",["/usr/lib/brgc/turbine_factory.lua"]="∏9≠Æ˛’mÑ\0Íë_Ÿ1>„7™ç0ß‹Ü≈æ≠ò7\25YF",["/usr/lib/brgc/reactor_factory.lua"]="*(\0VûE*¸∂¨o˛tÆ;8&aªBÈS}}/±l\11€X¯\0",["/usr/lib/brgc/config.lua"]="Òc\20¯uÏ¥≤b‰y¥„AoÚkÄ¸/á\4˚k˝Y\0299\20\\œZ",["/usr/lib/brgc/regulation_state.lua"]="t˘ÃÏ#≠8?,˘˛“uHâFç™5W√∑@?õm:˜ˆ‡ÇA",["/usr/lib/brgc/turbine_state.lua"]="\24B¥øIâ—Ò_‡ú Jºj]svMöÂ\0137ﬂNÄ‘\13˛S-\20",["/etc/rc.d/brgc_reactor.lua"]="NÃì`üÃÍù?¿öë\0\18+ød\6)AbºjÏπÔüñ≈mX;"},files={["/usr/lib/brgc/calibration_ringbuffer.lua"]="local oop = require(\"oop\")\13\n\13\nlocal calibration_ringbuffer = {\13\n\9mBuffer = nil,\13\n\9mSizeMax = 0,\13\n\9mAverage = nil,\13\n\9mStandardDeviation = nil,\13\n\9mMonotonicSince = 0,\13\n\9mMonotonicDirection = 0\13\n}\13\noop.make(calibration_ringbuffer)\13\n\13\nfunction calibration_ringbuffer:construct(size)\13\n\9checkArg(1, size, \"number\")\13\n\13\n\9self.mSizeMax = size\13\n\9self.mBuffer = {}\13\nend\13\n\13\nfunction calibration_ringbuffer:count()\13\n\9return  #self.mBuffer\13\nend\13\n\13\nfunction calibration_ringbuffer:getAverage()\13\n\9return self.mAverage\13\nend\13\n\13\nfunction calibration_ringbuffer:getStandardDeviation()\13\n\9return self.mStandardDeviation\13\nend\13\n\13\nfunction calibration_ringbuffer:isMonotonic()\13\n\9return #self.mBuffer > 0 and (#self.mBuffer - 1) / 3 <= self.mMonotonicSince\13\nend\13\n\13\nfunction calibration_ringbuffer:push(value)\13\n\9checkArg(1, value, \"number\")\13\n\13\n\9table.insert(self.mBuffer, value)\13\n\13\n\9while #self.mBuffer > self.mSizeMax do\13\n\9\9table.remove(self.mBuffer, 1)\13\n\9end\13\n\13\n\9local newAverage = self:calculateAverage()\13\n\13\n\9if #self.mBuffer > 1 then\13\n\9\9if self.mAverage > newAverage then\13\n\9\9\9if self.mMonotonicDirection == -1 then\13\n\9\9\9\9self.mMonotonicSince = math.min(self.mMonotonicSince + 1, self.mSizeMax)\13\n\9\9\9else\13\n\9\9\9\9self.mMonotonicSince = 1\13\n\9\9\9\9self.mMonotonicDirection = -1\13\n\9\9\9end\13\n\9\9elseif self.mAverage < newAverage then\13\n\9\9\9if self.mMonotonicDirection == 1 then\13\n\9\9\9\9self.mMonotonicSince = math.min(self.mMonotonicSince + 1, self.mSizeMax)\13\n\9\9\9else\13\n\9\9\9\9self.mMonotonicSince = 1\13\n\9\9\9\9self.mMonotonicDirection = 1\13\n\9\9\9end\13\n\9\9else\13\n\9\9\9self.mMonotonicSince = self.mMonotonicSince + 1\13\n\9\9end\13\n\9end\13\n\13\n\9self.mAverage = newAverage\13\n\9self.mStandardDeviation = self:calculateStandardDeviation()\13\nend\13\n\13\nfunction calibration_ringbuffer:calculateAverage()\13\n\9local avg = 0\13\n\13\n\9if #self.mBuffer == 0 then\13\n\9\9return nil\13\n\9end\13\n\13\n\9for _, val in pairs(self.mBuffer) do\13\n\9\9avg = avg + val / #self.mBuffer\13\n\9end\13\n\13\n\9return avg\13\nend\13\n\13\nfunction calibration_ringbuffer:calculateStandardDeviation()\13\n\9local avg = self:getAverage()\13\n\13\n\9if #self.mBuffer == 0 then\13\n\9\9return nil\13\n\9end\13\n\13\n\9local tmp = 0\13\n\9for _, val in pairs(self.mBuffer) do\13\n\9\9tmp = tmp + (val - avg) * (val - avg) / #self.mBuffer\13\n\9end\13\n\13\n\9return math.sqrt(tmp)\13\nend\13\n\13\nreturn calibration_ringbuffer\13\n",["/usr/lib/brgc/turbine_ctrl.lua"]="local computer = require(\"computer\")\nlocal component = require(\"component\")\nlocal event = require(\"event\")\nlocal reactor_api = require(\"brgc/reactor_ctrl\")\nlocal config = require(\"brgc/config\")\nlocal turbineState = require(\"brgc/turbine_state\")\nlocal turbineFactory = require(\"brgc/turbine_factory\")\n\n\nlocal turbine_api = {\n\9mTurbines = {},\n\9mDebug = false,\n\9mTimerId = nil\n}\n\nfunction turbine_api.reset()\n\9turbine_api.mTurbines = {}\nend\n\nfunction turbine_api.discover()\n\9local br_components = component.list(\"br_turbine\")\n\9config.load()\n\n\9for address, _ in pairs(br_components) do\n\9\9turbine_api.add(address)\n\9end\nend\n\nfunction turbine_api.add(address)\n\9checkArg(1, address, \"string\")\n\n\9if turbine_api.mTurbines[address] == nil then\n\9\9local turbine = turbineFactory(address)\n\9\9if turbine ~= nil then\n\9\9\9if not turbine:isDisabled() then\n\9\9\9\9reactor_api.setSteamProductionTarget(reactor_api.getSteamProductionTarget() + turbine:getSteamRate())\n\9\9\9end\n\n\9\9\9turbine_api.mTurbines[address] = turbine\n\n\9\9\9turbine_api.print(\"Connected with turbine \" .. address)\n\9\9\9computer.pushSignal(\"brgc_turbine_added\", address)\n\9\9end\n\9end\nend\n\nfunction turbine_api.remove(address)\n\9checkArg(1, address, \"string\")\n\n\9if turbine_api.mTurbines[address] ~= nil then\n\9\9reactor_api.setSteamProductionTarget(reactor_api.getSteamProductionTarget() - turbine_api.mTurbines[address]:getSteamRate())\n\9\9turbine_api.mTurbines[address] = nil\n\9\9computer.pushSignal(\"brgc_turbine_removed\", address)\n\9end\nend\n\nfunction turbine_api.reload()\n\9for address, turbine in pairs(turbine_api.mTurbines) do\n\9\9local turbine_config = config:getTurbineConfigOrDefault(address)\n\9\9if turbine_config and turbine:isConnected() then\n\9\9\9turbine:setEnergyProductionMax(turbine_config.energyProductionMax)\n\9\9\9turbine:setRPMMax(turbine_config.RPMMax)\n\9\9\9turbine:setIndependent(turbine_config.independent or false)\n\9\9end\n\9end\n\n\9local turbines = { }\n\9config.load()\n\n\9for address, _ in pairs(turbine_api.mTurbines) do\n\9\9table.insert(turbines, address)\n\9end\n\n\9for _, address in pairs(turbines) do\n\9\9turbine_api.remove(address)\n\9\9turbine_api.add(address)\n\9end\nend\n\nfunction turbine_api.runOnce()\n\9local steamNeeded = 0\n\n\9for _, turbine in pairs(turbine_api.mTurbines) do\n\9\9if turbine:isConnected() then\n\9\9\9turbine:runStateMachine()\n\9\9\9if turbine:isActive() then\n\9\9\9\9steamNeeded = steamNeeded + turbine:getSteamRate()\n\9\9\9end\n\9\9end\n\9end\n\n\9reactor_api.setSteamProductionTarget(steamNeeded)\nend\n\nfunction turbine_api.shutdown()\n\9turbine_api.setAsync(false)\n\9for _, turbine in pairs(turbine_api.mTurbines) do\n\9\9turbine:setState(turbineState.OFFLINE)\n\9end\n\9turbine_api.reset()\nend\n\nfunction turbine_api.start()\n\9if turbine_api.mTimerId ~= nil then\n\9\9return false\n\9else\n\9\9event.listen(\"component_added\", turbine_api.asyncComponentAddedHandler)\n\9\9event.listen(\"component_removed\", turbine_api.asyncComponentRemovedHandler)\n\9\9turbine_api.mTimerId = event.timer(1, turbine_api.asyncTimerHandler, math.huge)\n\9\9return true\n\9end\nend\n\nfunction turbine_api.stop()\n\9if turbine_api.mTimerId == nil then\n\9\9return false\n\9else\n\9\9event.ignore(\"component_added\", turbine_api.asyncComponentAddedHandler)\n\9\9event.ignore(\"component_removed\", turbine_api.asyncComponentRemovedHandler)\n\9\9event.cancel(turbine_api.mTimerId)\n\9\9turbine_api.mTimerId = nil\n\9\9return true\n\9end\nend\n\nfunction turbine_api.isRunning()\n\9return turbine_api.mTimerId ~= nil\nend\n\nfunction turbine_api.toggleDebug()\n\9turbine_api.mDebug = not turbine_api.mDebug\nend\n\nfunction turbine_api.print(...)\n\9if turbine_api.mDebug then\n\9\9print(...)\n\9end\nend\n\nfunction turbine_api.getTurbines()\n\9return turbine_api.mTurbines\nend\n\n-- Async handlers\n\nfunction turbine_api.asyncComponentAddedHandler(_, address, typeID)\n\9if typeID == \"br_turbine\" then\n\9\9turbine_api.add(address)\n\9end\nend\n\nfunction turbine_api.asyncComponentRemovedHandler(_, address, typeID)\n\9if typeID == \"br_turbine\" then\n\9\9turbine_api.remove(address)\n\9end\nend\n\nfunction turbine_api.asyncTimerHandler()\n\9xpcall(turbine_api.runOnce, function(...) io.stderr:write(debug.traceback(...) .. \"\\n\") end)\nend\n\nreturn turbine_api",["/usr/lib/brgc/reactor_state.lua"]="local reactorState = {\13\n\9ERROR = -2,\13\n\9OFFLINE = -1,\13\n\9CALIBRATING = 1,\13\n\9ONLINE = 2\13\n};\13\n\13\nfunction reactorState.toString(state)\13\n\9if\9\9state == reactorState.ERROR then\9\9return \"ERROR\"\13\n\9elseif\9state == reactorState.OFFLINE then\9\9return \"OFFLINE\"\13\n\9elseif\9state == reactorState.CALIBRATING then\9return \"CALIBRATING\"\13\n\9elseif\9state == reactorState.ONLINE then\9\9return \"ONLINE\"\13\n\9else\9\9\9\9\9\9\9\9\9\9\9return \"UNKNOWN\"\13\n\9end\13\nend\13\n\13\nreturn reactorState;",["/usr/lib/brgc/config.lua"]="local filesystem = require(\"filesystem\")\13\nlocal serialization = require(\"serialization\")\13\n\13\nlocal config_api = {\13\n\9turbines = { },\13\n\9reactors = { },\13\n\13\n\9default_turbine = { },\13\n\9default_reactor = { }\13\n}\13\n\13\nfunction config_api.writeComponentData(file, address, data)\13\n\9file:write(\"        [\\\"\" .. tostring(address) .. \"\\\"] = {\\n\")\13\n\9local maxPropNameLength = 0\13\n\13\n\9for key, _ in pairs(data) do\13\n\9\9if string.len(key) > maxPropNameLength then\13\n\9\9\9maxPropNameLength = string.len( key )\13\n\9\9end\13\n\9end\13\n\13\n\9for key, value in pairs(data) do\13\n\9\9if type(value) == \"table\" then\13\n\9\9\9file:write(string.format( \"            % \" .. tostring(maxPropNameLength) .. \"s = %s,\\n\",\13\n\9\9\9\9key, serialization.serialize(value)))\13\n\9\9elseif type(value) == \"string\" then\13\n\9\9\9file:write(string.format( \"            % \" .. tostring(maxPropNameLength) .. \"s = \\\"%s\\\",\\n\",\13\n\9\9\9\9key, value))\13\n\9\9else\13\n\9\9\9file:write(string.format( \"            % \" .. tostring(maxPropNameLength) .. \"s = %s,\\n\",\13\n\9\9\9\9key, tostring(value)))\13\n\9\9end\13\n\9end\13\n\13\n\9file:write(\"        },\\n\")\13\nend\13\n\13\nfunction config_api.load()\13\n\9local f = io.open(\"/etc/br_control.cfg\",\"r\")\13\n\9if f then\13\n\9\9local config_string = f:read(\"*all\")\13\n\9\9f:close()\13\n\9\9local config = serialization.unserialize(config_string)\13\n\9\9if config then\13\n\9\9\9config_api.turbines = {}\13\n\9\9\9for address, turbine in pairs(config.turbines or {}) do\13\n\9\9\9\9if address == \"default\" then\13\n\9\9\9\9\9config_api.default_turbine = turbine\13\n\9\9\9\9else\13\n\9\9\9\9\9config_api.turbines[address] = turbine\13\n\9\9\9\9end\13\n\9\9\9end\13\n\13\n\9\9\9config_api.reactors = {}\13\n\9\9\9for address, reactor in pairs(config.reactors or {}) do\13\n\9\9\9\9if address == \"default\" then\13\n\9\9\9\9\9config_api.default_reactor = reactor\13\n\9\9\9\9else\13\n\9\9\9\9\9config_api.reactors[address] = reactor\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9\9return true\13\n\9\9end\13\n\9end\13\n\9return false\13\nend\13\n\13\nfunction config_api.save()\13\n\9local root = filesystem.get(\"/\")\13\n\9if root and not root.isReadOnly() then\13\n\9\9filesystem.makeDirectory(\"/etc\")\13\n\9\9local f = io.open(\"/etc/br_control.cfg\", \"w\")\13\n\13\n\9\9if f then\13\n\9\9\9-- Sort reactors\13\n\9\9\9local reactors = {}\13\n\9\9\9for address, reactor in pairs(config_api.reactors) do\13\n\9\9\9\9table.insert(reactors, { address = address, reactor = reactor })\13\n\9\9\9end\13\n\9\9\9table.sort(reactors, function(a,b) return a.address < b.address end)\13\n\13\n\9\9\9-- Sort turbines\13\n\9\9\9local turbines = {}\13\n\9\9\9for address, turbine in pairs(config_api.turbines) do\13\n\9\9\9\9table.insert(turbines, { address = address, turbine = turbine })\13\n\9\9\9end\13\n\9\9\9table.sort(turbines, function(a,b) return a.address < b.address end)\13\n\13\n\9\9\9-- Write data\13\n\9\9\9f:write(\"{\\n\")\13\n\9\9\9f:write(\"    reactors = {\\n\")\13\n\13\n\9\9\9config_api.writeComponentData(f, \"default\", config_api.default_reactor)\13\n\9\9\9for _, v in pairs(reactors) do\13\n\9\9\9\9config_api.writeComponentData(f, v.address, v.reactor)\13\n\9\9\9end\13\n\13\n\9\9\9f:write(\"    },\\n\")\13\n\9\9\9f:write(\"    turbines = {\\n\")\13\n\13\n\9\9\9config_api.writeComponentData(f, \"default\", config_api.default_turbine)\13\n\9\9\9for _, v in pairs(turbines) do\13\n\9\9\9\9config_api.writeComponentData(f, v.address, v.turbine)\13\n\9\9\9end\13\n\13\n\9\9\9f:write(\"    }\\n\")\13\n\9\9\9f:write(\"}\\n\")\13\n\9\9\9f:close()\13\n\9\9end\13\n\9end\13\nend\13\n\13\nfunction config_api.setReactor(address, config)\13\n\9config_api.reactors[address] = config\13\n\9config_api.save()\13\nend\13\n\13\nfunction config_api.setReactorAttribute(address, var, val)\13\n\9config_api.reactors[address][var] = val\13\n\9config_api.save()\13\nend\13\n\13\nfunction config_api.getReactorConfig(address)\13\n\9return config_api.reactors[address]\13\nend\13\n\13\nfunction config_api.getDefaultReactorConfig()\13\n\9return config_api.default_reactor\13\nend\13\n\13\nfunction config_api.getReactorConfigOrDefault(address)\13\n\9local config = config_api.getReactorConfig(address)\13\n\9if config then\13\n\9\9return config\13\n\9else\13\n\9\9local newconfig = { }\13\n\9\9setmetatable(newconfig, { __index = config_api.getDefaultReactorConfig() })\13\n\9\9return newconfig\13\n\9end\13\nend\13\n\13\nfunction config_api.setTurbine(address, config)\13\n\9config_api.turbines[address] = config\13\n\9config_api.save()\13\nend\13\n\13\nfunction config_api.setTurbineAttribute(address, var, val)\13\n\9config_api.turbines[address][var] = val\13\n\9config_api.save()\13\nend\13\n\13\nfunction config_api.getTurbineConfig(address)\13\n\9return config_api.turbines[address]\13\nend\13\n\13\nfunction config_api.getDefaultTurbineConfig()\13\n\9return config_api.default_turbine\13\nend\13\n\13\nfunction config_api.getTurbineConfigOrDefault(address)\13\n\9local config = config_api.getTurbineConfig(address)\13\n\9if config then\13\n\9\9return config\13\n\9else\13\n\9\9local newconfig = { }\13\n\9\9setmetatable(newconfig, { __index = config_api.getDefaultTurbineConfig() })\13\n\9\9return newconfig\13\n\9end\13\nend\13\n\13\n\13\nreturn config_api",["/usr/lib/brgc/turbine.lua"]="local computer = require(\"computer\")\nlocal component = require(\"component\")\nlocal oop = require(\"oop\")\nlocal config_api = require(\"brgc/config\")\nlocal turbineState = require(\"brgc/turbine_state\")\n\n\nlocal gRPMDanger = 1950\nlocal gRPMMax = 1850\nlocal gRPMMin = 750\nlocal gRPMSkipHigh = 1450\nlocal gRPMSkipLow = 980\nlocal gEnergyStoredMax = 1000000\nlocal gNumTurbinesTransient = 0\n\nlocal turbineStateData = {\n--[[\n\9[turbineState.ERROR]\9\9= { active = false, inductor = true }\n\9[turbineState.OFFLINE]\9\9= { active = false, inductor = false }\n\9[turbineState.STARTING]\9\9= { active = false, inductor = false }\n\9[turbineState.CALIBRATING]\9= { active = true, inductor = true }\n\9[turbineState.KICKOFF]\9\9= { active = true, inductor = false }\n\9[turbineState.SPINUP]\9\9= { active = true, inductor = false }\n\9[turbineState.SPINUP_SLOW]\9= { active = true, inductor = true }\n\9[turbineState.SPINDOWN]\9\9= { active = false, inductor = true }\n\9[turbineState.SPINDOWN_FAST]= { active = false, inductor = true }\n\9[turbineState.STABLE]\9\9= { active = true, inductor = true }\n\9[turbineState.SUSPENDED]\9= { active = false, inductor = false }\n--]]\n}\n\nturbineStateData[turbineState.ERROR]\9\9= { active = false, inductor = true }\nturbineStateData[turbineState.OFFLINE]\9\9= { active = false, inductor = false }\nturbineStateData[turbineState.STARTING]\9\9= { active = false, inductor = false }\nturbineStateData[turbineState.CALIBRATING]\9= { active = true, inductor = true }\nturbineStateData[turbineState.KICKOFF]\9\9= { active = true, inductor = false }\nturbineStateData[turbineState.SPINUP]\9\9= { active = true, inductor = false }\nturbineStateData[turbineState.SPINUP_SLOW]\9= { active = true, inductor = true }\nturbineStateData[turbineState.SPINDOWN]\9\9= { active = false, inductor = true }\nturbineStateData[turbineState.SPINDOWN_FAST]= { active = false, inductor = true }\nturbineStateData[turbineState.STABLE]\9\9= { active = true, inductor = true }\nturbineStateData[turbineState.SUSPENDED]\9= { active = false, inductor = false }\n\n\nlocal turbine = {\n\9mAddress = nil,\n\9mComponent = nil,\n\9mSteamMax = nil,\n\9mRPMTarget = 0,\n\9mEnergyStoredTarget = gEnergyStoredMax / 2,\n\n\9mState = turbineState.OFFLINE,\n\n\9mTurbineConfig = {\n\9\9outputRateMax = nil,\n\9\9rpmMax = nil,\n\9\9disabled = false,\n\9\9independent = false\n\9},\n\n\9mTurbineStats = {\n\9\9outputRateCurrent = 0,\n\9\9outputExtractionRate = 0,\n\n\9\9outputStoredCurrent = 0,\n\9\9outputStoredLast = 0,\n\9\9outputStoredRate = 0,\n\9\9outputCapacity = 0,\n\n\9\9rpmCurrent = 0,\n\9\9rpmLast = 0,\n\9\9rpmRate = 0,\n\n\9\9steamRate = 0,\n\n\9\9tickLast = 0,\n\9\9timeDiff = 0\n\9}\n}\noop.make(turbine)\n\nfunction turbine:construct(address, config)\n\9checkArg(1, address, \"string\")\n\9checkArg(2, config, \"table\", \"nil\")\n\n\9self.mAddress = address\n\9self.mTurbineConfig = config or { }\n\9self.mTurbineStats = { }\n\n\9setmetatable(self.mTurbineConfig, {__index = turbine.mTurbineConfig})\n\9setmetatable(self.mTurbineStats, {__index = turbine.mTurbineStats})\nend\n\nfunction turbine:connect()\n\9self.mComponent = component.proxy(self.mAddress)\n\9if self.mComponent == nil then\n\9\9return false\n\9end\n\9self.mSteamMax = 25 * self.mComponent.getNumberOfBlades()\n\9self:updateStats()\n\n\9if not self:isDisabled() then\n\9\9self:setState(turbineState.STARTING)\n\9end\n\n\9return true\nend\n\nfunction turbine:isConnected()\n\9if not self.mComponent then\n\9\9return false\n\9elseif self.mComponent.mbIsConnected then\n\9\9-- New API\n\9\9local success, state = pcall(self.mComponent.mbIsConnected)\n\n\9\9return success and state\n\9elseif self.mComponent.getConnected then\n\9\9-- Old API\n\9\9local success, state = pcall(self.mComponent.getConnected)\n\n\9\9return success and state\n\9end\n\n\9-- Nothing of the above is true? Welp... we don't seem to be connected then!\n\9return false\nend\n\nfunction turbine:isReady()\n\9local isAssembled = true\n\n\9if self.mComponent.mbIsAssembled then\n\9\9local success, state = pcall(self.mComponent.mbIsAssembled)\n\n\9\9isAssembled = success and state\n\9end\n\n\9return isAssembled\nend\n\nfunction turbine:getAddress()\n\9return self.mAddress\nend\n\nfunction turbine:getAddressShort()\n\9return string.sub(self.mAddress,1,3)\nend\n\nfunction turbine:isDisabled()\n\9return not not self.mTurbineConfig.disabled\nend\n\nfunction turbine:setDisabled(disabled)\n\9-- Don't update if nothing changed. Saves some i/o.\n\9if self.mTurbineConfig.disabled ~= not not disabled then\n\9\9self.mTurbineConfig.disabled = not not disabled\n\9\9config_api.setTurbine(self:getAddress(), self.mTurbineConfig)\n\9end\nend\n\nfunction turbine:isIndependent()\n\9return self.mTurbineConfig.independent\nend\n\nfunction turbine:setIndependent(independent)\n\9-- Don't update if nothing changed. Saves some i/o.\n\9if self.mTurbineConfig.independent ~= not not independent then\n\9\9self.mTurbineConfig.independent = not not independent\n\9\9config_api.setTurbine(self:getAddress(), self.mTurbineConfig)\n\9end\nend\n\nfunction turbine:isCalibrated()\n\9return self:getRPMMax() ~= nil\nend\n\nfunction turbine:getOutputStats()\n\9if self.mComponent.getEnergyStats then\n\9\9local stats = self.mComponent.getEnergyStats()\n\9\9return {\n\9\9\9outputStored = stats.energyStored,\n\9\9\9outputCapacity = stats.energyCapacity,\n\9\9\9outputProducedLastTick = stats.energyProducedLastTick\n\9\9}\n\9else\n\9\9return {\n\9\9\9outputStored = self.mComponent.getEnergyStored(),\n\9\9\9outputCapacity = gEnergyStoredMax,\n\9\9\9outputProducedLastTick = self.mComponent.getEnergyProducedLastTick()\n\9\9}\n\9end\nend\n\nfunction turbine:updateStats()\n\9-- If we're not connected, we can't do anything really.\n\9-- In otder to avoid computing wierd stuff as soon as the turbine reconnects,\n\9-- we're going to reset the stats instead.\n\9if not self:isConnected() then\n\9\9self.mTurbineConfig = { }\n\9\9setmetatable(self.mTurbineStats, {__index = turbine.mTurbineStats})\n\9end\n\n\9local now = computer.uptime() * 20\n\9local timediff = now - self.mTurbineStats.tickLast\n\n\9-- Did we advance at least on tick?\n\9if timediff <= 0 then\n\9\9-- We've already been called this tick. No need to do anything.\n\9\9-- This it NOT an optimization. Stuff will break if we go any further.\n\9\9return false\n\9end\n\n\9local outputStats = self:getOutputStats()\n\n\9-- Shift current stats to last stats\n\9self.mTurbineStats.outputStoredLast = self.mTurbineStats.outputStoredCurrent\n\9self.mTurbineStats.rpmLast = self.mTurbineStats.rpmCurrent\n\n\9-- Update raw stats\n\9self.mTurbineStats.outputRateCurrent = outputStats.outputProducedLastTick\n\9self.mTurbineStats.outputStoredCurrent = outputStats.outputStored\n\9self.mTurbineStats.outputCapacity = outputStats.outputCapacity\n\9self.mTurbineStats.rpmCurrent = self.mComponent.getRotorSpeed()\n\9self.mTurbineStats.steamRate = self:getSteamRateDirect()\n\n\9-- Update rates\n\9-- If tickLast is 0 then this is the first iteration and we can't compute any rates.\n\9if self.mTurbineStats.tickLast > 0 then\n\9\9self.mTurbineStats.outputStoredRate = ( self.mTurbineStats.outputStoredCurrent - self.mTurbineStats.outputStoredLast ) / timediff\n\9\9self.mTurbineStats.outputExtractionRate = math.max( 0, self.mTurbineStats.outputRateCurrent - self.mTurbineStats.outputStoredRate )\n\9\9self.mTurbineStats.rpmRate = ( self.mTurbineStats.rpmCurrent - self.mTurbineStats.rpmLast ) / timediff\n\9end\n\n\9self.mTurbineStats.tickLast = now\n\9self.mTurbineStats.timeDiff = timediff\n\9-- Fail for the first time so nobody can accidentally run the statemachine and crash.\n\9return ( timediff ~= now )\nend\n\n-- Getters related to rotor speed (RPM)\n\nfunction turbine:getRPM()\n\9return self.mTurbineStats.rpmCurrent\nend\n\nfunction turbine:getRPMMax()\n\9return self.mTurbineConfig.rpmMax\nend\n\nfunction turbine:getRPMRate()\n\9return self.mTurbineStats.rpmRate\nend\n\nfunction turbine:getRPMOptimal()\n\9return self.mTurbineConfig.rpmMax\nend\n\nfunction turbine:getRPMTarget()\n\9return self.mRPMTarget\nend\n\nfunction turbine:setRPMTarget(rpm)\n\9checkArg(1, rpm, \"number\")\n\9self.mRPMTarget = rpm\nend\n\n-- Getters related to the turbines output\n\nfunction turbine:getOutputGenerationRate()\n\9return self.mTurbineStats.outputRateCurrent\nend\n\nfunction turbine:getOutputGenerationRateMax()\n\9return self.mTurbineConfig.outputRateMax\nend\n\nfunction turbine:getOutputExtractionRate()\n\9return self.mTurbineStats.outputExtractionRate\nend\n\nfunction turbine:getOptimalOutputGenerationRate()\n\9return self.mTurbineConfig.outputRateMax\nend\n\nfunction turbine:getOutputStored()\n\9return self.mTurbineStats.outputStoredCurrent\nend\n\nfunction turbine:getOutputStoredRate()\n\9return self.mTurbineStats.outputStoredRate\nend\n\nfunction turbine:getOutputStoredMax()\n\9return self.mTurbineStats.outputCapacity\nend\n\nfunction turbine:estimateOutputGenerationRate()\n\9if turbineStateData[self:getState()].inductor then\n\9\9return self:getOutputGenerationRate()\n\9else\n\9\9return self:getOutputGenerationRateMax() * self:RPM2Percent(self:getRPM())\n\9end\nend\n\n-- Getters related to steam\n\nfunction turbine:getSteamRateDirect()\n\9return self.mComponent.getFluidFlowRateMax()\nend\n\nfunction turbine:getSteamRate()\n\9return self.mTurbineStats.steamRate\nend\n\nfunction turbine:setSteamRate(rate)\n\9checkArg(1, rate, \"number\")\n\9self.mComponent.setFluidFlowRateMax(rate)\n\9self.mTurbineStats.streamRate = self:getSteamRateDirect()\nend\n\n--\n\nfunction turbine:getState()\n\9return self.mState\nend\n\nfunction turbine:setState(state)\n\9local oldStateStable = turbineStateData[self.mState].inductor or not turbineStateData[self.mState].active\n\9local newStateStable = turbineStateData[state].inductor or not turbineStateData[state].active\n\9local oldState = self.mState\n\9local rpmCurrent = self:getRPM()\n\9local rpmMax = self:getRPMMax()\n\n\9if oldStateStable and not newStateStable then\n\9\9gNumTurbinesTransient = gNumTurbinesTransient + 1\n\9elseif not oldStateStable and newStateStable then\n\9\9gNumTurbinesTransient = gNumTurbinesTransient - 1\n\9end\n\n\9self.mState = state\n\9self.mComponent.setInductorEngaged(turbineStateData[state].inductor)\n\9self.mComponent.setActive(turbineStateData[state].active)\n\n\9if state == turbineState.STARTING then\n\9\9if rpmMax == nil and rpmCurrent >= 1700 then\n\9\9\9self:setState(turbineState.CALIBRATING)\n\9\9elseif rpmMax == nil then\n\9\9\9self:setState(turbineState.KICKOFF)\n\9\9elseif rpmMax ~= nil and (\n\9\9\9\9\9\9\9\9\9\9rpmCurrent >= rpmMax * 0.95 and oldState ~= turbineState.SUSPENDED or\n\9\9\9\9\9\9\9\9\9\9rpmCurrent >= gRPMSkipHigh and oldState == turbineState.SUSPENDED or\n\9\9\9\9\9\9\9\9\9\9rpmCurrent >= gRPMMin and rpmCurrent <= gRPMSkipLow) then\n\n\9\9\9self:setState(turbineState.STABLE)\n\9\9\9self:setRPM(rpmCurrent, true)\n\9\9else\n\9\9\9if rpmCurrent >= gRPMMin * 0.9 and rpmCurrent <= gRPMSkipLow then\n\9\9\9\9self.mRPMTarget = gRPMMin + (gRPMSkipLow - gRPMMin) / 2\n\9\9\9else\n\9\9\9\9self.mRPMTarget = rpmMax * 0.95\n\9\9\9end\n\9\9\9self:setState(turbineState.KICKOFF)\n\9\9end\n\9elseif state == turbineState.KICKOFF or state == turbineState.CALIBRATING then\n\9\9self:setOutput(1, true)\n\9end\nend\n\nfunction turbine:isRPMStable()\n\9-- return math.floor(self.mRPMLast * 250 + 0.5) == math.floor(self:getRPM() * 250 + 0.5)\n\9return math.abs(self:getRPMRate()) < 0.00025\nend\n\nfunction turbine:setRPM(targetrpm, ignorecurrent)\n\9checkArg(1, targetrpm, \"number\")\n\9checkArg(2, ignorecurrent, \"boolean\", \"nil\")\n\n\9local rpmCurrent = self:getRPM()\n\n\9if targetrpm > gRPMMax then\n\9\9targetrpm = gRPMMax\n\9elseif targetrpm < gRPMMin then\n\9\9targetrpm = gRPMMin\n\9end\n\n\9if not ignorecurrent then\n\9\9if rpmCurrent  >= gRPMSkipHigh * 0.95 and targetrpm < gRPMSkipHigh then\n\9\9\9if targetrpm > (gRPMSkipHigh+gRPMSkipLow) / 2 or rpmCurrent * 0.99 >= gRPMSkipHigh then\n\9\9\9\9targetrpm = gRPMSkipHigh\n\9\9\9\9if math.sqrt(rpmCurrent) * 0.995 > math.sqrt(targetrpm) then\n\9\9\9\9\9self:setState(turbineState.SPINDOWN_FAST)\n\9\9\9\9end\n\9\9\9else\n\9\9\9\9targetrpm = (gRPMMin + gRPMSkipLow) / 2\n\9\9\9\9self:setState(turbineState.SPINDOWN)\n\9\9\9end\n\9\9elseif rpmCurrent * 0.95 <= gRPMSkipLow and targetrpm > gRPMSkipLow then\n\9\9\9if gNumTurbinesTransient > 0 or targetrpm < (gRPMSkipHigh+gRPMSkipLow) / 2 or rpmCurrent <= gRPMSkipLow * 0.99 then\n\9\9\9\9targetrpm = gRPMSkipLow\n\9\9\9\9if math.sqrt(rpmCurrent) < math.sqrt(targetrpm) * 0.98 then\n\9\9\9\9\9self:setState(turbineState.SPINUP_SLOW)\n\9\9\9\9end\n\9\9\9else\n\9\9\9\9targetrpm = (gRPMMax + gRPMSkipHigh) / 2\n\9\9\9\9self:setState(turbineState.SPINUP)\n\9\9\9end\n\9\9end\n\9end\n\n\9if math.sqrt(rpmCurrent) * 0.992 > math.sqrt(targetrpm) and (self.mState == turbineState.STABLE or self.mState == turbineState.SPINUP_SLOW) then\n\9\9self:setState(turbineState.SPINDOWN_FAST)\n\9elseif math.sqrt(rpmCurrent) < math.sqrt(targetrpm) * 0.98 and (self.mState == turbineState.STABLE or self.mState == turbineState.SPINDOWN_FAST) then\n\9\9self:setState(turbineState.SPINUP_SLOW)\n\9end\n\n\9self.mRPMTarget = targetrpm\n\9if self.mState == turbineState.SPINUP_SLOW or self.mState == turbineState.SPINUP then\n\9\9self:setSteamRate(self.mSteamMax)\n\9else\n\9\9self:setSteamRate(self:RPM2Steam(targetrpm))\n\9end\nend\n\nfunction turbine:RPM2Steam(rpm)\n\9checkArg(1, rpm, \"number\")\n\n\9return (rpm / self:getRPMMax()) * self.mSteamMax\nend\n\nfunction turbine:RPM2Percent(rpm)\n\9checkArg(1, rpm, \"number\")\n\n\9if rpm >= gRPMSkipHigh then\n\9\9return math.max(1, rpm / self:getRPMMax())\n\9elseif rpm >= gRPMMin and rpm <= gRPMSkipLow then\n\9\9return rpm / gRPMSkipLow / 2\n\9else\n\9\9return 0\n\9end\nend\n\nfunction turbine:Percent2RPM(percent)\n\9checkArg(1, percent, \"number\")\n\n\9if percent >= 0.5 then\n\9\9return gRPMSkipHigh + (self:getRPMMax() - gRPMSkipHigh) * (percent - 0.5) * 2\n\9else\n\9\9return gRPMSkipLow * percent * 2\n\9end\nend\n\nfunction turbine:setOutput(output, force)\n\9checkArg(1, output, \"number\")\n\n\9if self:getRPMMax() == nil then\n\9\9self:setSteamRate(self.mSteamMax)\n\9else\n\9\9self.mRPMTarget = self:Percent2RPM(output)\n\9\9self:setRPM(self.mRPMTarget, force)\n\9end\nend\n\nfunction turbine:isActive()\n\9return self.mState ~= turbineState.SUSPENDED and self.mState ~= turbineState.OFFLINE and self.mState ~= turbineState.ERROR\nend\n\nfunction turbine:isOverburdened()\n\9return self:isActive() and self:getRPMMax() ~= nil and self:getRPM() >= self:getRPMMax() * 0.95 and self:getOutputStored() <= self:getOutputGenerationRate() * 2 and self.mComponent.getInductorEngaged()\nend\n\nfunction turbine:readyForSuspend()\n\9return turbine:isActive() and self:getRPM() * 0.95 <= gRPMMin and self:getOutputStored() >= self:getOutputStoredMax() - self:getOutputGenerationRate() * 2\nend\n\nfunction turbine:needsHelp()\n\9return self:isActive() and (self:getOutputStored() <= self:getOutputGenerationRate() * 2 or (self:getOutputStored() <= self:getOutputStoredMax()/4 and self:getOutputStoredRate() < 0 ))\nend\n\nfunction turbine:isTransient()\n\9return turbineStateData[self.mState].active and not turbineStateData[self.mState].inductor\nend\n\nfunction turbine:recalibrate()\n\9self:setState(turbineState.OFFLINE)\n\n\9self.mTurbineConfig = {\n\9\9disabled = self.mTurbineConfig.disabled,\n\9\9independent = self.mTurbineConfig.independent\n\9}\n\9self.mTurbineStats = { }\n\9setmetatable(self.mTurbineConfig, {__index = turbine.mTurbineConfig})\n\9setmetatable(self.mTurbineStats, {__index = turbine.mTurbineStats})\n\n\9config_api.setTurbine(self:getAddress(), self.mTurbineConfig)\n\9self:setState(turbineState.STARTING)\nend\n\nfunction turbine:runStateMachine()\n\9-- Before we run anything we try to update the turbines stats.\n\9-- If this function fails the stats have either been cleared\n\9-- or they're incomplete so we return early.\n\9if not self:updateStats() then\n\9\9return\n\9end\n\n\9local rpmCurrent = self:getRPM()\n\9local steamUsageMax = self:getSteamRate()\n\n\9if rpmCurrent >= gRPMDanger then\n\9\9self:setState(turbineState.ERROR)\n\9elseif self.mState == turbineState.CALIBRATING then\n\9\9if self:isRPMStable() then\n\9\9\9self.mTurbineConfig.rpmMax = rpmCurrent\n\9\9\9self.mTurbineConfig.outputRateMax = self:getOutputGenerationRate()\n\9\9\9config_api.setTurbine(self:getAddress(), self.mTurbineConfig)\n\9\9\9self:setState(turbineState.STABLE)\n\9\9end\n\9elseif self.mState == turbineState.KICKOFF then\n\9\9if not self:isCalibrated() and rpmCurrent >= 1780 then\n\9\9\9self:setState(turbineState.CALIBRATING)\n\9\9elseif self:isCalibrated() and rpmCurrent >= self.mRPMTarget then\n\9\9\9self:setState(turbineState.STABLE)\n\9\9\9self:setRPM(rpmCurrent, true)\n\9\9end\n\9elseif self.mState == turbineState.SPINDOWN then\n\9\9if self.mRPMTarget >= rpmCurrent * 0.95 then\n\9\9\9self:setState(turbineState.STABLE)\n\9\9end\n\9elseif self.mState == turbineState.SPINUP then\n\9\9if rpmCurrent >= self.mRPMTarget * 0.95 then\n\9\9\9self:setState(turbineState.STABLE)\n\9\9end\n\9elseif self.mState == turbineState.SPINUP_SLOW then\n\9\9if self:RPM2Steam(rpmCurrent) >= steamUsageMax * 0.98 then\n\9\9\9self:setState(turbineState.STABLE)\n\9\9end\n\9\9self:regulate()\n\9elseif self.mState == turbineState.SPINDOWN_FAST then\n\9\9if self:RPM2Steam(rpmCurrent) * 0.98 <= steamUsageMax then\n\9\9\9self:setState(turbineState.STABLE)\n\9\9end\n\9\9self:regulate()\n\9elseif self.mState == turbineState.STABLE then\n\9\9self:regulate()\n\9end\nend\n\nfunction turbine:regulate()\n\9local energyStored = self:getOutputStored()\n\9local energyStoredRate = self:getOutputStoredRate()\n\9local energyTargetDelta = self.mEnergyStoredTarget - energyStored\n\9local targetEnergyProduction\n\n\9local pEnergyStoredDelta = 0\n\9local pEnergyProductionDelta = 0\n\9local energyOffset\n\n\9if energyStored < 1 and energyStoredRate < 1 then\n\9\9targetEnergyProduction = self:getOutputGenerationRateMax()\n\9elseif energyStored >= self:getOutputStoredMax() - self:getOutputGenerationRate() and energyStoredRate >= 0 then\n\9\9targetEnergyProduction = 0\n\9else\n\9\9targetEnergyProduction = self:getOutputExtractionRate()\n\9\9pEnergyStoredDelta = energyTargetDelta / self:getOutputStoredMax()\n\9\9pEnergyProductionDelta = 0-energyStoredRate / self:getOutputGenerationRateMax()\n\9end\n\n\9energyOffset = pEnergyStoredDelta * 0.55 + pEnergyProductionDelta * 5\n\n\9self:setOutput( targetEnergyProduction / self:getOutputGenerationRateMax() + energyOffset )\nend\n\n\nreturn turbine\n",["/usr/lib/brgc/reactor_base.lua"]="local computer = require(\"computer\")\13\nlocal component = require(\"component\")\13\nlocal oop = require(\"oop\")\13\nlocal config_api = require(\"brgc/config\")\13\nlocal reactorState = require(\"brgc/reactor_state\")\13\nlocal regulationState = require(\"brgc/regulation_state\")\13\nlocal calibration_ringbuffer = require(\"brgc/calibration_ringbuffer\")\13\nlocal polynomial = require(\"polynomial\")\13\n\13\nlocal reactorCalibrationMaxOutput = {0.01,0.02,0.05,0.1,0.15,0.2,0.25,0.3,0.35,0.4,0.5,0.6,0.7,0.75,0.8,0.9,1}\13\n\13\nlocal reactor_base = {\13\n\9mAddress = nil,\13\n\9mComponent = nil,\13\n\9mPassive = nil,\13\n\9mRodNum = 0,\13\n\9mRodLevelState = nil,\13\n\9mRodLevel = 0,\13\n\9mRodTarget = 0,\13\n\9mRodOffset = 0,\13\n\9mOutputRateOpt = 0,\13\n\9mOutputRateMax = 0,\13\n\9mState = reactorState.OFFLINE,\13\n\9mRegulationState = regulationState.NONE,\13\n\9mAPI2IsBugged = false,\13\n\13\n\9mReactorConfig = {\13\n\9\9rodLevelMin = 0,\13\n\9\9outputOpt = 0,\13\n\9\9outputPoly = nil,\13\n\9\9outputReversePoly = polynomial.make({0, 1}),\13\n\9\9regulationBehaviour = regulationState.GRID,\13\n\9\9disabled = false,\13\n\9\9PWMLevelOnline = 0.15,\13\n\9\9PWMLevelOffline = 0.8,\13\n\9},\13\n\13\n\9mReactorStats = {\13\n\9\9outputRateCurrent = 0,\13\n\9\9outputExtractionRate = 0,\13\n\13\n\9\9outputStoredCurrent = 0,\13\n\9\9outputStoredLast = 0,\13\n\9\9outputStoredRate = 0,\13\n\9\9outputCapacity = 0,\13\n\13\n\9\9temperatureFuelCurrent = 0,\13\n\9\9temperatureFuelLast = 0,\13\n\9\9temperatureFuelRate = 0,\13\n\13\n\9\9fuelLevel = 0,\13\n\9\9fuelRate = 0,\13\n\13\n\9\9tickLast = 0,\13\n\9\9timeDiff = 0\13\n\9},\13\n\13\n\9-- calibration stuff\13\n\9mCalibrationData = nil,\13\n\9mCalibrationStep = nil,\13\n\9mCalibrationTemperatureRingbuffer = nil,\13\n\9mCalibrationValueRingbuffer = nil,\13\n\9mCalibrationTemperatureDeviationRingbuffer = nil,\13\n\9mCalibrationValueDeviationRingbuffer = nil\13\n}\13\noop.make(reactor_base)\13\n\13\nfunction reactor_base:construct(address, config)\13\n\9checkArg(1, address, \"string\")\13\n\9checkArg(2, config, \"table\", \"nil\")\13\n\13\n\9self.mAddress = address\13\n\9self.mReactorConfig = config or { }\13\n\9self.mReactorStats = { }\13\n\13\n\9setmetatable(self.mReactorConfig, {__index = reactor_base.mReactorConfig})\13\n\9setmetatable(self.mReactorStats, {__index = reactor_base.mReactorStats})\13\n\13\n\9if config ~= nil then\13\n\9\9if type(config.outputPoly) == \"table\" and type(config.outputPoly.coefs) == \"table\" then\13\n\9\9\9self.mReactorConfig.outputPoly = polynomial.make(config.outputPoly.coefs)\13\n\9\9else\13\n\9\9\9self.mReactorConfig.outputPoly = nil\13\n\9\9end\13\n\9\9if type(config.outputReversePoly) == \"table\" and type(config.outputReversePoly.coefs) == \"table\" then\13\n\9\9\9self.mReactorConfig.outputReversePoly = polynomial.make(config.outputReversePoly.coefs)\13\n\9\9else\13\n\9\9\9self.mReactorConfig.outputReversePoly = nil\13\n\9\9end\13\n\9end\13\nend\13\n\13\nfunction reactor_base:connect()\13\n\9self.mComponent = component.proxy(self.mAddress)\13\n\9if self.mComponent == nil then\13\n\9\9return false\13\n\9end\13\n\9self.mPassive = not self.mComponent.isActivelyCooled()\13\n\9self.mRodNum = self.mComponent.getNumberOfControlRods()\13\n\9self:updateStats()\13\n\13\n\9if self.init and not self:isDisabled() then\13\n\9\9self:init()\13\n\9end\13\n\13\n\9return true\13\nend\13\n\13\nfunction reactor_base:isConnected()\13\n\9if not self.mComponent then\13\n\9\9return false\13\n\9elseif self.mComponent.mbIsConnected then\13\n\9\9-- New API\13\n\9\9local success, state = pcall(self.mComponent.mbIsConnected)\13\n\13\n\9\9return success and state\13\n\9elseif self.mComponent.getConnected then\13\n\9\9-- Old API\13\n\9\9local success, state = pcall(self.mComponent.getConnected)\13\n\13\n\9\9return success and state\13\n\9end\13\n\13\n\9-- Nothing of the above is true? Welp... we don't seem to be connected then!\13\n\9return false\13\nend\13\n\13\nfunction reactor_base:isReady()\13\n\9local isAssembled = true\13\n\13\n\9if self.mComponent.mbIsAssembled then\13\n\9\9local success, state = pcall(self.mComponent.mbIsAssembled)\13\n\13\n\9\9isAssembled = success and state\13\n\9end\13\n\13\n\9return isAssembled\13\nend\13\n\13\nfunction reactor_base:isActivelyCooled()\13\n\9return not self.mPassive\13\nend\13\n\13\nfunction reactor_base:isDisabled()\13\n\9return not not self.mReactorConfig.disabled\13\nend\13\n\13\nfunction reactor_base:getState()\13\n\9return self.mState\13\nend\13\n\13\nfunction reactor_base:getAddress()\13\n\9return self.mAddress\13\nend\13\n\13\nfunction reactor_base:getAddressShort()\13\n\9return string.sub(self.mAddress, 1, 3)\13\nend\13\n\13\nfunction reactor_base:getOutputOpt()\13\n\9return self.mReactorConfig.outputOpt\13\nend\13\n\13\nfunction reactor_base:getRegulationBehaviour()\13\n\9return self.mReactorConfig.regulationBehaviour\13\nend\13\n\13\nfunction reactor_base:setRegulationBehaviour(behaviour)\13\n\9assert(behaviour == regulationState.AUTO or behaviour == regulationState.PWM or behaviour == regulationState.LOAD or behaviour == regulationState.GRID, \"Invalid behaviour\")\13\n\9self.mReactorConfig.regulationBehaviour = behaviour\13\n\9config_api.setReactor(self:getAddress(), self.mReactorConfig)\13\nend\13\n\13\nfunction reactor_base:getRegulationBehaviour()\13\n\9return self.mReactorConfig.regulationBehaviour\13\nend\13\n\13\nfunction reactor_base:setDisabled(disabled)\13\n\9-- Don't update if nothing changed. Saves some i/o.\13\n\9if self.mReactorConfig.disabled ~= not not disabled then\13\n\9\9self.mReactorConfig.disabled = not not disabled\13\n\9\9config_api.setReactor(self:getAddress(), self.mReactorConfig)\13\n\9end\13\nend\13\n\13\nfunction reactor_base:getFuelStats()\13\n\9if self.mComponent.getFuelStats then\13\n\9\9return self.mComponent.getFuelStats()\13\n\9else\13\n\9\9return {\13\n\9\9\9fuelTemperature = self.mComponent.getFuelTemperature(),\13\n\9\9\9fuelAmount = self.mComponent.getFuelAmount(),\13\n\9\9\9wasteAmount = self.mComponent.getWasteAmount(),\13\n\9\9\9fuelCapacity = self.mComponent.getFuelAmountMax(),\13\n\9\9\9fuelConsumedLastTick = self.mComponent.getFuelConsumedLastTick()\13\n\9\9}\13\n\9end\13\nend\13\n\13\nfunction reactor_base:updateStats()\13\n\9-- If we're not connected, we can't do anything really.\13\n\9-- In order to avoid computing wierd stuff as soon as the reactor reconnects,\13\n\9-- we're going to reset the stats instead.\13\n\9if not self:isConnected() then\13\n\9\9self.mReactorStats = { }\13\n\9\9setmetatable(self.mReactorStats, {__index = reactor_base.mReactorStats})\13\n\9\9return false\13\n\9end\13\n\13\n\9local now = computer.uptime() * 20\13\n\9local timediff = now - self.mReactorStats.tickLast\13\n\13\n\9-- Did we advance at least one tick?\13\n\9if timediff <= 0 then\13\n\9\9-- We've already been called this tick. No need to do anything.\13\n\9\9-- This it NOT an optimization. Stuff will break if we go any further.\13\n\9\9return false\13\n\9end\13\n\13\n\9local outputStats = self:getOutputStats()\13\n\9local fuelStats = self:getFuelStats()\13\n\13\n\9-- Shift current stats to last stats\13\n\9self.mReactorStats.outputStoredLast = self.mReactorStats.outputStoredCurrent\13\n\9self.mReactorStats.temperatureFuelLast = self.mReactorStats.temperatureFuelCurrent\13\n\13\n\9-- Update output stats\13\n\9self.mReactorStats.outputRateCurrent = outputStats.outputProducedLastTick\13\n\9self.mReactorStats.outputStoredCurrent = outputStats.outputStored\13\n\9self.mReactorStats.outputCapacity = outputStats.outputCapacity\13\n\13\n\9-- Update fuel stats\13\n\9self.mReactorStats.temperatureFuelCurrent = fuelStats.fuelTemperature\13\n\9-- TODO: Once waste is returned by this, add that as well\13\n\9self.mReactorStats.fuelLevel = (fuelStats.fuelAmount + fuelStats.wasteAmount / 100) / fuelStats.fuelCapacity\13\n\9self.mReactorStats.fuelRate = fuelStats.fuelConsumedLastTick\13\n\13\n\9-- Update rates\13\n\9-- If tickLast is 0 then this is the first iteration and we can't compute any rates.\13\n\9if self.mReactorStats.tickLast > 0 then\13\n\9\9self.mReactorStats.outputStoredRate = ( self.mReactorStats.outputStoredCurrent - self.mReactorStats.outputStoredLast ) / timediff\13\n\9\9self.mReactorStats.outputExtractionRate = math.max( 0, self.mReactorStats.outputRateCurrent - self.mReactorStats.outputStoredRate )\13\n\9\9self.mReactorStats.temperatureFuelRate = ( self.mReactorStats.temperatureFuelCurrent - self.mReactorStats.temperatureFuelLast ) / timediff\13\n\9end\13\n\13\n\9self.mReactorStats.tickLast = now\13\n\9self.mReactorStats.timeDiff = timediff\13\n\9-- Fail for the first time so nobody can accidentally run the statemachine and crash.\13\n\9return (timediff ~= now)\13\nend\13\n\13\n-- Getters related to fuel temperature\13\n\13\nfunction reactor_base:getFuelTemperature()\13\n\9return self.mReactorStats.temperatureFuelCurrent\13\nend\13\n\13\nfunction reactor_base:getNormalizedFuelTemperature()\13\n\9local fuelLevel = self:getFuelLevel()\13\n\9if fuelLevel == 0 then\13\n\9\9return 0\13\n\9else\13\n\9\9return self:getFuelTemperature() / fuelLevel\13\n\9end\13\nend\13\n\13\nfunction reactor_base:getFuelTemperatureRate()\13\n\9return self.mReactorStats.temperatureFuelRate\13\nend\13\n\13\n-- Getters related to fuel consumption\13\n\13\nfunction reactor_base:getFuelConsumedLastTick()\13\n\9return self.mReactorStats.fuelRate\13\nend\13\n\13\n-- Getters related to the fuel tank\13\n\13\nfunction reactor_base:getFuelLevel()\13\n\9return self.mReactorStats.fuelLevel\13\nend\13\n\13\n-- Getters related to the reactors output\13\n\13\nfunction reactor_base:getOutputGenerationRate()\13\n\9return self.mReactorStats.outputRateCurrent\13\nend\13\n\13\nfunction reactor_base:getOutputGenerationRateMax()\13\n\9return self.mOutputRateMax\13\nend\13\n\13\nfunction reactor_base:getNormalizedOutputGenerationRate()\13\n\9local fuelLevel = self:getFuelLevel()\13\n\9if fuelLevel == 0 then\13\n\9\9return 0\13\n\9else\13\n\9\9return self:getOutputGenerationRate() / fuelLevel\13\n\9end\13\nend\13\n\13\nfunction reactor_base:getOutputExtractionRate()\13\n\9return self.mReactorStats.outputExtractionRate\13\nend\13\n\13\nfunction reactor_base:getOptimalOutputGenerationRate()\13\n\9return self.mOutputRateOpt\13\nend\13\n\13\nfunction reactor_base:getCurrentOptimalOutputGenerationRate()\13\n\9-- This is only an approximation. The correct value requires the fuel level\13\n\9-- to be multiplied with the rod level and then put through the polynome\13\n\9return self:getOptimalOutputGenerationRate() * self:getFuelLevel()\13\nend\13\n\13\nfunction reactor_base:getOutputStored()\13\n\9return self.mReactorStats.outputStoredCurrent\13\nend\13\n\13\nfunction reactor_base:getOutputStoredMax()\13\n\9return self.mReactorStats.outputCapacity\13\nend\13\n\13\nfunction reactor_base:getOutputStoredRate()\13\n\9return self.mReactorStats.outputStoredRate\13\nend\13\n\13\nfunction reactor_base:isCalibrated()\13\n\9return self:getOptimalOutputGenerationRate() ~= nil and self.mReactorConfig.outputPoly ~= nil\13\nend\13\n\13\n-- Rod logic\13\n\13\nfunction reactor_base:setRodLevelRaw(rawlevel)\13\n\9if self.mComponent.setControlRodsLevels and not reactor_base.mAPI2IsBugged then\13\n\9\9self:setRodLevelRawAPI2(rawlevel)\13\n\9elseif self.mComponent.setAllControlRodLevels and self.mComponent.setControlRodLevel then\13\n\9\9self:setRodLevelRawAPI1(rawlevel)\13\n\9else\13\n\9\9error('Unable to find appropriate API function for setting control rods on reactor ' .. self.mAddress)\13\n\9end\13\nend\13\n\13\nfunction reactor_base:getRodIdxFromCenter(idx)\13\n\9checkArg(1, idx, \"number\")\13\n\13\n\9local centerRodIdx = math.floor(self.mRodNum / 2)\13\n\9local rodIdxOffset = math.ceil(idx / 2)\13\n\13\n\9if idx % 2 == 0 then\13\n\9\9rodIdxOffset = 0 - rodIdxOffset\13\n\9end\13\n\13\n\9local actualIdx = centerRodIdx + rodIdxOffset\13\n\13\n\9if actualIdx == self.mRodNum then\13\n\9\9actualIdx = 0\13\n\9elseif actualIdx == -1 then\13\n\9\9actualIdx = self.mRodNum - 1\13\n\9end\13\n\13\n\9assert(actualIdx >= 0 and actualIdx < self.mRodNum, \"Detected bug in rod idx calculation\")\13\n\13\n\9return actualIdx\13\nend\13\n\13\nfunction reactor_base:calculateRodLevelInfo(rawlevel)\13\n\9checkArg(1, rawlevel, \"number\")\13\n\13\n\9local rodLevel\13\n\9local rodLevelMin = self.mReactorConfig.rodLevelMin or 0\13\n\9local rodExtraLevel\13\n\9local rodLevelRounded\13\n\13\n\9if rawlevel > self.mRodNum * (100-rodLevelMin) then\13\n\9\9rawlevel = self.mRodNum * (100-rodLevelMin)\13\n\9elseif rawlevel < 0 then\13\n\9\9rawlevel = 0\13\n\9end\13\n\13\n\9rodLevelRounded = math.floor(rawlevel+0.5)\13\n\9local roadLevelf = rodLevelMin + rawlevel / self.mRodNum\13\n\9rodLevel = math.floor(roadLevelf)\13\n\9rodExtraLevel = math.floor((roadLevelf - rodLevel) * self.mRodNum + 0.5)\13\n\13\n\9if rodLevel > 100 then\13\n\9\9rodLevel = 100\13\n\9\9rodExtraLevel = 0\13\n\9end\13\n\13\n\9return rodLevelRounded, rodLevel, rodExtraLevel\13\nend\13\n\13\nfunction reactor_base:setRodLevelRawAPI1(rawlevel)\13\n\9checkArg(1, rawlevel, \"number\")\13\n\13\n\9local rodLevelRounded, rodLevel, rodExtraLevel = self:calculateRodLevelInfo(rawlevel)\13\n\9local rodLevelState = rodLevel * self.mRodNum + rodExtraLevel\13\n\13\n\9-- If the combined rod level did not change, there is no need to call into\13\n\9-- the reactor API. We can leave things as they were.\13\n\9if self.mRodLevelState ~= rodLevelState then\13\n\9\9-- In order to minimize the API calls required to set all rods, we\13\n\9\9-- first set all rods to the rod level the majority of the rods have to\13\n\9\9-- be set to and afterwards correct the other rod leves.\13\n\9\9if rodExtraLevel <= self.mRodNum / 2 then\13\n\9\9\9self.mComponent.setAllControlRodLevels(rodLevel)\13\n\9\9\9for i=0, rodExtraLevel-1 do\13\n\9\9\9\9self:setRodLevelDirectFromCenterAPI1(i, rodLevel+1)\13\n\9\9\9end\13\n\9\9else\13\n\9\9\9self.mComponent.setAllControlRodLevels(rodLevel+1)\13\n\9\9\9for i=rodExtraLevel, self.mRodNum-1 do\13\n\9\9\9\9self:setRodLevelDirectFromCenterAPI1(i, rodLevel)\13\n\9\9\9end\13\n\9\9end\13\n\13\n\9\9self.mRodLevel = rodLevelRounded\13\n\9\9self.mRodLevelState = rodLevelState\13\n\9end\13\nend\13\n\13\nfunction reactor_base:setRodLevelDirectFromCenterAPI1(idx, level)\13\n\9checkArg(1, idx, \"number\")\13\n\9checkArg(2, level, \"number\")\13\n\13\n\9if level < 0 or level > 100 then\13\n\9\9return\13\n\9end\13\n\13\n\9self.mComponent.setControlRodLevel(self:getRodIdxFromCenter(idx), level)\13\nend\13\n\13\nfunction reactor_base:setRodLevelRawAPI2(rawlevel)\13\n\9checkArg(1, rawlevel, \"number\")\13\n\13\n\9local rodLevelRounded, rodLevel, rodExtraLevel = self:calculateRodLevelInfo(rawlevel)\13\n\9local rodLevelState = rodLevel * self.mRodNum + rodExtraLevel\13\n\13\n\9-- If the combined rod level did not change, there is no need to call into\13\n\9-- the reactor API. We can leave things as they were.\13\n\9if self.mRodLevelState ~= rodLevelState then\13\n\9\9local rodLevelTable = {}\13\n\13\n\9\9for i=0, rodExtraLevel-1 do\13\n\9\9\9rodLevelTable[self:getRodIdxFromCenter(i)] = rodLevel+1\13\n\9\9end\13\n\9\9for i=rodExtraLevel, self.mRodNum-1 do\13\n\9\9\9rodLevelTable[self:getRodIdxFromCenter(i)] = rodLevel\13\n\9\9end\13\n\13\n\9\9local retval, error = self.mComponent.setControlRodsLevels(rodLevelTable)\13\n\9\9if retval == nil and error ~= nil then\13\n\9\9\9reactor_base.mAPI2IsBugged = true\13\n\9\9\9return self:setRodLevelRawAPI1(rawlevel)\13\n\9\9end\13\n\13\n\9\9self.mRodLevel = rodLevelRounded\13\n\9\9self.mRodLevelState = rodLevelState\13\n\9end\13\nend\13\n\13\nfunction reactor_base:translateFromLinearOutput(level)\13\n\9checkArg(1, level, \"number\")\13\n\9return self.mReactorConfig.outputReversePoly:eval(self.mOutputRateMax * level)\13\nend\13\n\13\nfunction reactor_base:translateToLinearOutput(level)\13\n\9checkArg(1, level, \"number\")\13\n\9return self.mReactorConfig.outputPoly:eval(level) / self.mOutputRateMax\13\nend\13\n\13\nfunction reactor_base:setOutput(levelpercent, offset)\13\n\9checkArg(1, levelpercent, \"number\")\13\n\9checkArg(2, offset, \"number\", \"nil\")\13\n\13\n\9local rodLevelMin = self.mReactorConfig.rodLevelMin or 0\13\n\9if offset ~= nil then\13\n\9\9self.mRodOffset = 0-self.mRodNum*(100-rodLevelMin)*offset\13\n\9end\13\n\9self.mRodTarget = self.mRodNum*(100-rodLevelMin)*(1-levelpercent)\13\n\9self:setRodLevelRaw( self.mRodTarget + self.mRodOffset )\13\nend\13\n\13\nfunction reactor_base:setOutputOffset(offsetpercent)\13\n\9checkArg(1, offsetpercent, \"number\")\13\n\13\n\9local rodLevelMin = self.mReactorConfig.rodLevelMin or 0\13\n\9self.mRodOffset = 0-self.mRodNum*(100-rodLevelMin)*offsetpercent\13\n\9self:setRodLevelRaw( self.mRodTarget + self.mRodOffset )\13\nend\13\n\13\nfunction reactor_base:getOutputOffset()\13\n\9if self.mReactorConfig.rodLevelMin == 100 then\13\n\9\9return 0\13\n\9else\13\n\9\9return 0-self.mRodOffset/(100-self.mReactorConfig.rodLevelMin)/self.mRodNum\13\n\9end\13\nend\13\n\13\nfunction reactor_base:getOutput()\13\n\9return math.max(0, math.min(1, 1 - (self.mRodTarget + self.mRodOffset) / (100 - self.mReactorConfig.rodLevelMin) / self.mRodNum))\13\nend\13\n\13\nfunction reactor_base:setActive(active)\13\n\9checkArg(1, active, \"boolean\")\13\n\13\n\9self.mComponent.setActive(active)\13\nend\13\n\13\nfunction reactor_base:setOutputPolynomialCoefs(coefs)\13\n\9checkArg(1, coefs, \"table\", \"nil\")\13\n\13\n\9if coefs ~= nil then\13\n\9\9self.mReactorConfig.outputPoly = polynomial.make(coefs.coefs or coefs)\13\n\9end\13\nend\13\n\13\nfunction reactor_base:setOutputReversePolynomialCoefs(coefs)\13\n\9checkArg(1, coefs, \"table\", \"nil\")\13\n\13\n\9if coefs ~= nil then\13\n\9\9self.mReactorConfig.outputReversePoly = polynomial.make(coefs.coefs or coefs)\13\n\9end\13\nend\13\n\13\nfunction reactor_base:recalculateOpts()\13\n\9if self.mReactorConfig.outputPoly ~= nil and self.mReactorConfig.outputReversePoly ~= nil then\13\n\9\9self.mOutputRateMax = self.mReactorConfig.outputPoly:eval(1)\13\n\9\9self.mOutputRateOpt = self.mReactorConfig.outputPoly:eval(self.mReactorConfig.outputOpt)\13\n\9end\13\nend\13\n\13\nfunction reactor_base:setState(state)\13\n\9self.mState = state\13\n\13\n\9if state == reactorState.ERROR or state == reactorState.OFFLINE then\13\n\9\9self.mComponent.setActive(false)\13\n\9elseif state == reactorState.CALIBRATING then\13\n\9\9self.mCalibrationData = {}\13\n\9\9self.mCalibrationStep = 1\13\n\9\9self:setOutput(reactorCalibrationMaxOutput[1])\13\n\9\9self.mComponent.setActive(true)\13\n\9elseif state == reactorState.ONLINE then\13\n\9\9if not self:isCalibrated() then\13\n\9\9\9self:setState(reactorState.CALIBRATING)\13\n\9\9else\13\n\9\9\9self.mComponent.setActive(true)\13\n\9\9end\13\n\9else\13\n\9\9error(\"Invalid reactor state supplied: \" + tostring(state))\13\n\9end\13\nend\13\n\13\nfunction reactor_base:recalibrate()\13\n\9self:setState(reactorState.OFFLINE)\13\n\13\n\9self.mReactorConfig = {\13\n\9\9regulationBehaviour = self.mReactorConfig.regulationBehaviour,\13\n\9\9disabled = self.mReactorConfig.disabled,\13\n\9\9PWMLevelOnline = self.mReactorConfig.PWMLevelOnline,\13\n\9\9PWMLevelOffline = self.mReactorConfig.PWMLevelOffline\13\n\9}\13\n\9self.mReactorStats = { }\13\n\13\n\9setmetatable(self.mReactorConfig, {__index = reactor_base.mReactorConfig})\13\n\9setmetatable(self.mReactorStats, {__index = reactor_base.mReactorStats})\13\n\13\n\9config_api.setReactor(self:getAddress(), self.mReactorConfig)\13\n\9self:setState(reactorState.ONLINE)\13\nend\13\n\13\nfunction reactor_base:initCalibrationBuffers()\13\n\9self.mCalibrationValueRingbuffer = calibration_ringbuffer(10)\13\n\9self.mCalibrationTemperatureRingbuffer = calibration_ringbuffer(10)\13\n\9self.mCalibrationValueDeviationRingbuffer = calibration_ringbuffer(10)\13\n\9self.mCalibrationTemperatureDeviationRingbuffer = calibration_ringbuffer(10)\13\nend\13\n\13\nfunction reactor_base:clearCalibrationBuffers()\13\n\9self.mCalibrationTemperatureRingbuffer = nil\13\n\9self.mCalibrationValueRingbuffer = nil\13\n\9self.mCalibrationTemperatureDeviationRingbuffer = nil\13\n\9self.mCalibrationValueDeviationRingbuffer = nil\13\nend\13\n\13\nfunction reactor_base:runCalibration()\13\n\9local calibValue = self:getNormalizedOutputGenerationRate()\13\n\9local calibTemp = self:getNormalizedFuelTemperature()\13\n\13\n\9if self.mCalibrationTemperatureRingbuffer == nil or self.mCalibrationValueRingbuffer == nil or self.mCalibrationTemperatureDeviationRingbuffer == nil or self.mCalibrationValueDeviationRingbuffer == nil then\13\n\9\9self:initCalibrationBuffers()\13\n\9end\13\n\13\n\9self.mCalibrationValueRingbuffer:push(calibValue)\13\n\9self.mCalibrationValueDeviationRingbuffer:push(self.mCalibrationValueRingbuffer:getStandardDeviation())\13\n\13\n\9self.mCalibrationTemperatureRingbuffer:push(calibTemp)\13\n\9self.mCalibrationTemperatureDeviationRingbuffer:push(self.mCalibrationTemperatureRingbuffer:getStandardDeviation())\13\n\13\n\9-- Scientific sure fire methods to find out if the reactor is in a stable\13\n\9-- condition. Both of these conditions need to be true for that to be the\13\n\9-- case.\13\n\9local nonMonotonic = not self.mCalibrationTemperatureRingbuffer:isMonotonic() and not self.mCalibrationValueRingbuffer:isMonotonic()\13\n\9local stable = not self.mCalibrationValueDeviationRingbuffer:isMonotonic() and not self.mCalibrationTemperatureDeviationRingbuffer:isMonotonic()\13\n\13\n\9-- Dirty hacks to allow faster calibration. Either one of these can replace\13\n\9-- the respective scientific calculation.\13\n\9local isCloseEnough = (math.abs(self.mCalibrationTemperatureRingbuffer:getAverage() - calibTemp) < self.mCalibrationTemperatureRingbuffer:getAverage() / 1000) and (self.mCalibrationTemperatureRingbuffer:count() == 10)\13\n\9\9\9\9\9or (math.abs(self.mCalibrationValueRingbuffer:getAverage() - calibValue) < self.mCalibrationValueRingbuffer:getAverage() / 1000) and (self.mCalibrationValueRingbuffer:count() == 10)\13\n\9local lowDeviation = self.mCalibrationTemperatureRingbuffer:getStandardDeviation() <= self.mCalibrationTemperatureRingbuffer:getAverage() / 1000\13\n\9\9\9\9\9and self.mCalibrationValueRingbuffer:getStandardDeviation() <= self.mCalibrationValueRingbuffer:getAverage() / 1000\13\n\13\n\9-- If you found this, congratulations ;)\13\n\9-- Here are some leftover debug prints that allow you to get an idea what's\13\n\9-- going on during reactor calibration.\13\n\13\n--[[\13\n\9print(string.format( \"temp avg: %.03f std: %.03f stable: %s\",\13\n\9\9self.mCalibrationTemperatureRingbuffer:getAverage(),\13\n\9\9self.mCalibrationTemperatureRingbuffer:getStandardDeviation(),\13\n\9\9tostring(not self.mCalibrationTemperatureDeviationRingbuffer:isMonotonic())\13\n\9))\13\n\9print(string.format( \"val  avg: %.03f std: %.03f stable: %s\",\13\n\9\9self.mCalibrationValueRingbuffer:getAverage(),\13\n\9\9self.mCalibrationValueRingbuffer:getStandardDeviation(),\13\n\9\9tostring(not self.mCalibrationValueDeviationRingbuffer:isMonotonic())\13\n\9))\13\n\9print(\"nonMonotonic: \" .. tostring(nonMonotonic) ..\13\n\9\9\" lowDeviation: \" .. tostring(lowDeviation) ..\13\n\9\9\" stable: \" .. tostring(stable) ..\13\n\9\9\" isClose: \" .. tostring(isCloseEnough)\13\n\9)\13\n--]]\13\n\9if not self:isGood() then\13\n\9\9self:finalizeCalibration()\13\n\9elseif (nonMonotonic or isCloseEnough) and (lowDeviation or stable) then\13\n\9\9if calibValue ~= nil and reactorCalibrationMaxOutput[self.mCalibrationStep] ~= nil then\13\n\9\9\9if type(self.mCalibrationData) ~= \"table\" then\13\n\9\9\9\9self.mCalibrationData = { }\13\n\9\9\9end\13\n\9\9\9table.insert(self.mCalibrationData, {\13\n\9\9\9\9step = self.mCalibrationStep,\13\n\9\9\9\9load = reactorCalibrationMaxOutput[self.mCalibrationStep],\13\n\9\9\9\9value = self.mCalibrationValueRingbuffer:getAverage(),\13\n\9\9\9\9efficiency = self.mCalibrationValueRingbuffer:getAverage() / self:getFuelConsumedLastTick()\13\n\9\9\9})\13\n\13\n--\9\9\9print(\"----------\")\13\n\13\n\9\9\9self.mCalibrationStep = self.mCalibrationStep + 1\13\n\9\9\9if reactorCalibrationMaxOutput[self.mCalibrationStep] ~= nil then\13\n\9\9\9\9self:initCalibrationBuffers()\13\n\9\9\9\9self:setOutput(reactorCalibrationMaxOutput[self.mCalibrationStep], 0)\13\n\9\9\9else\13\n\9\9\9\9self:clearCalibrationBuffers()\13\n\9\9\9\9self:finalizeCalibration()\13\n\9\9\9end\13\n\9\9else\13\n\9\9\9self:clearCalibrationBuffers()\13\n\9\9\9self:finalizeCalibration()\13\n\9\9end\13\n\9end\13\n\9self.mCalibrationValueLast = calibValue\13\nend\13\n\13\nfunction reactor_base:runStateMachine()\13\n\9-- Before we run anything we try to update the reactors stats.\13\n\9-- If this function fails the stats have either been cleared\13\n\9-- or they're incomplete so we return early.\13\n\9if not self:updateStats() then\13\n\9\9return\13\n\9end\13\n\13\n\9if self.mState == reactorState.CALIBRATING then\13\n\9\9self:runCalibration()\13\n\9elseif self.mState == reactorState.ONLINE then\13\n\9\9self:regulate()\13\n\9end\13\nend\13\n\13\nreturn reactor_base\13\n",["/etc/rc.d/brgc_turbine.lua"]="--[[\13\nInit script for Big Reactors Grid Control - Turbine Controller for OpenComputers by XyFreak\13\nWebsite: http://tenyx.de/brgc/\13\n--]]\13\n\13\nlocal turbine_ctrl = require(\"brgc/turbine_ctrl\")\13\n\13\nfunction start()\13\n\9if turbine_ctrl.isRunning() then\13\n\9\9io.stderr:write(\"Big Reactors Grid Control - Turbine Controller service already running.\")\13\n\9else\13\n\9\9turbine_ctrl.discover()\13\n\9\9turbine_ctrl.start()\13\n\9end\13\nend\13\n\13\nfunction stop()\13\n\9if not turbine_ctrl.isRunning() then\13\n\9\9io.stderr:write(\"Big Reactors Grid Control - Turbine Controller service not running.\")\13\n\9else\13\n\9\9turbine_ctrl.stop()\13\n\9end\13\nend\13\n\13\nfunction restart()\13\n\9turbine_ctrl.reset()\13\n\9turbine_ctrl.discover()\13\n\9if not turbine_ctrl.isRunning() then\13\n\9\9turbine_ctrl.start()\13\n\9end\13\nend\13\n\13\nfunction status()\13\n\9if turbine_ctrl.isRunning() then\13\n\9\9io.write(\"Big Reactors Grid Control - Turbine Controller is running.\")\13\n\9else\13\n\9\9io.write(\"Big Reactors Grid Control - Turbine Controller is not running.\")\13\n\9end\13\nend",["/usr/lib/brgc/grid_controller.lua"]="local computer = require(\"computer\")\13\nlocal component = require(\"component\")\13\nlocal event = require(\"event\")\13\nlocal reactorState = require(\"brgc/reactor_state\")\13\nlocal turbineState = require(\"brgc/turbine_state\")\13\nlocal regulationState = require(\"brgc/regulation_state\")\13\nlocal reactor_api = require(\"brgc/reactor_ctrl\")\13\nlocal turbine_api = require(\"brgc/turbine_ctrl\")\13\nlocal energy_storage_component = require(\"brgc/energy_storage_component\")\13\n\13\nlocal controllerState = {\13\n\9PWM_OFF = 0,\13\n\9PWM_ON = 1,\13\n\9LOAD = 2\13\n}\13\n\13\nlocal grid_controller = {\13\n\9mTimerId = nil,\13\n\9mReactorsSorted = nil,\13\n\9mTurbinesSorted = nil,\13\n\9mEnergyStorage = {},\13\n\13\n\9mStats = {\13\n\9\9energyProductionRateReactors = 0,\13\n\9\9energyProductionRateReactorsMax = 0,\13\n\9\9energyProductionRateTurbines = 0,\13\n\9\9energyProductionRateTurbinesMax = 0,\13\n\9\9energyProductionRate = 0,\13\n\9\9energyExtractionRate = 0,\13\n\9\9energyExtractionRateWeighted = 0,\13\n\13\n\9\9energyStoredMax = 0,\13\n\9\9energyStoredCurrent = 0,\13\n\9\9energyStoredLast = 0,\13\n\9\9energyStoredRate = 0,\13\n\13\n\9\9tickLast = 0,\13\n\9\9timeDiff = 0,\13\n\9\9negativeExtractionRateSince = 0,\13\n\9},\13\n\13\n\13\n\9mEnergyStoredTarget = nil,\13\n\9mState = controllerState.PWM_OFF,\13\n\9mCharge = false,\13\n\9mPWMLimitUpper = 0.95,\13\n\9mPWMLimitLower = 0.20,\13\n}\13\n\13\nfunction grid_controller.updateStats()\13\n\9local now = computer.uptime() * 20\13\n\9local timediff = now - grid_controller.mStats.tickLast\13\n\13\n\9-- Did we advance at least one tick?\13\n\9if timediff <= 0 then\13\n\9\9-- We've already been called this tick. No need to do anything.\13\n\9\9-- This it NOT an optimization. Stuff will break if we continue.\13\n\9\9return false\13\n\9end\13\n\13\n\9for _, storage in pairs(grid_controller.mEnergyStorage) do\13\n\9\9if storage:isGood() then\13\n\9\9\9storage:update()\13\n\9\9end\13\n\9end\13\n\13\n\9grid_controller.mReactorsSorted = grid_controller.getReactors()\13\n\9grid_controller.mTurbinesSorted = grid_controller.getTurbines()\13\n\13\n\9-- Shift current stats to last stats\13\n\9grid_controller.mStats.energyStoredLast = grid_controller.mStats.energyStoredCurrent\13\n\13\n\9-- Update raw sats\13\n\9grid_controller.mStats.energyStoredMax = grid_controller.getMaxEnergyStoredDirect()\13\n\9grid_controller.mStats.energyStoredCurrent = grid_controller.getEnergyStoredDirect()\13\n\9grid_controller.mStats.energyProductionRateReactors = grid_controller.getEnergyProductionRateReactorsDirect()\13\n\9grid_controller.mStats.energyProductionRateReactorsMax = grid_controller.getEnergyProductionRateReactorsMaxDirect()\13\n\9grid_controller.mStats.energyProductionRateTurbines = grid_controller.getEnergyProductionRateTurbinesDirect()\13\n\9grid_controller.mStats.energyProductionRateTurbinesMax = grid_controller.getEnergyProductionRateTurbinesMaxDirect()\13\n\9grid_controller.mStats.energyProductionRate = grid_controller.mStats.energyProductionRateTurbines + grid_controller.mStats.energyProductionRateReactors\13\n\13\n\9-- Check if some energy components have gone offline. If so, reset the\13\n\9-- weighted extraction rate, as this thing might underflow so bad it'll be\13\n\9-- a while until it's positive again otherwise.\13\n\9if grid_controller.mStats.energyStoredLast > grid_controller.mStats.energyStoredMax then\13\n\9\9grid_controller.mStats.energyExtractionRateWeighted = 0\13\n\9end\13\n\13\n\9-- Update rates\13\n\9-- If tickLast is 0 then this is the first iteration and we can't compute any rates.\13\n\9if grid_controller.mStats.tickLast > 0 then\13\n\9\9grid_controller.mStats.energyStoredRate = ( grid_controller.mStats.energyStoredCurrent - grid_controller.mStats.energyStoredLast ) / timediff\13\n\9\9grid_controller.mStats.energyExtractionRate = grid_controller.mStats.energyProductionRate - grid_controller.mStats.energyStoredRate\13\n\13\n\9\9-- Compute the weighted extraction rate\13\n\9\9local weight = math.pow(grid_controller.mStats.energyStoredCurrent / grid_controller.mStats.energyStoredMax, 0.25)\13\n\9\9grid_controller.mStats.energyExtractionRateWeighted = weight * grid_controller.mStats.energyExtractionRateWeighted + ( 1 - weight ) * grid_controller.mStats.energyExtractionRate\13\n\9end\13\n\13\n\9if grid_controller.mStats.energyExtractionRate < 0 then\13\n\9\9grid_controller.mStats.negativeExtractionRateSince = grid_controller.mStats.negativeExtractionRateSince + 1\13\n\9elseif grid_controller.mStats.negativeExtractionRateSince > 0 then\13\n\9\9grid_controller.mStats.negativeExtractionRateSince = 0\13\n\9end\13\n\13\n\9grid_controller.mStats.tickLast = now\13\n\9grid_controller.mStats.timeDiff = timediff\13\n\13\n\9-- Fail for the first time so nobody can accidentally run the state machine and crash.\13\n\9return (timediff ~= now)\13\nend\13\n\13\nfunction grid_controller.getMaxEnergyStoredDirect()\13\n\9local maxEnergyStored = 0\13\n\13\n\9for _, storage in pairs(grid_controller.mEnergyStorage) do\13\n\9\9if storage:isGood() then\13\n\9\9\9maxEnergyStored = maxEnergyStored + storage:getMaxEnergyStored()\13\n\9\9end\13\n\9end\13\n\13\n\9return maxEnergyStored\13\nend\13\n\13\nfunction grid_controller.getMaxEnergyStored()\13\n\9return grid_controller.mStats.energyStoredMax\13\nend\13\n\13\nfunction grid_controller.getEnergyStoredDirect()\13\n\9local energyStored = 0\13\n\13\n\9for _, storage in pairs(grid_controller.mEnergyStorage) do\13\n\9\9if storage:isGood() then\13\n\9\9\9energyStored = energyStored + storage:getEnergyStored()\13\n\9\9end\13\n\9end\13\n\13\n\9return energyStored\13\nend\13\n\13\nfunction grid_controller.getEnergyStored()\13\n\9return grid_controller.mStats.energyStoredCurrent\13\nend\13\n\13\nfunction grid_controller.getEnergyStoredRate()\13\n\9return grid_controller.mStats.energyStoredRate\13\nend\13\n\13\nfunction grid_controller.getReactors()\13\n\9local reactors = {}\13\n\13\n\9for _, reactor in pairs(reactor_api.mReactors) do\13\n\9\9if\13\n\9\9\9reactor:isConnected()\13\n\9\9\9and not reactor:isDisabled()\13\n\9\9\9and not reactor:isActivelyCooled()\13\n\9\9\9and reactor:isCalibrated()\13\n\9\9\9and reactor:getRegulationBehaviour() == regulationState.GRID\13\n\9\9\9and reactor:getFuelLevel() > 0\13\n\9\9then\13\n\9\9\9table.insert(reactors, reactor)\13\n\9\9end\13\n\9end\13\n\13\n\9table.sort(reactors, function(a, b) return a:getCurrentOptimalOutputGenerationRate() > b:getCurrentOptimalOutputGenerationRate() end)\13\n\9return reactors\13\nend\13\n\13\nfunction grid_controller.getTurbines()\13\n\9local turbines = {}\13\n\13\n\9for _, turbine in pairs(turbine_api.mTurbines) do\13\n\9\9if\13\n\9\9\9turbine:isConnected()\13\n\9\9\9and not turbine:isDisabled()\13\n\9\9\9and turbine:isCalibrated()\13\n\9\9\9and not turbine:isIndependent()\13\n\9\9\9and turbine:getState() ~= turbineState.ERROR\13\n\9\9\9and not turbine:isTransient()\13\n\9\9then\13\n\9\9\9table.insert(turbines, turbine)\13\n\9\9end\13\n\9end\13\n\13\n\9table.sort(turbines, function(a, b) return a:getRPM() > b:getRPM() end)\13\n\9return turbines\13\nend\13\n\13\nfunction grid_controller.getOptEnergyProduction()\13\n\9local optEnergyProduction = 0\13\n\13\n\9for _, turbine in pairs(grid_controller.mTurbinesSorted) do\13\n\9\9optEnergyProduction = optEnergyProduction + turbine:getOutputGenerationRateMax()\13\n\9end\13\n\13\n\9for _, reactor in pairs(grid_controller.mReactorsSorted) do\13\n\9\9optEnergyProduction = optEnergyProduction + reactor:getCurrentOptimalOutputGenerationRate()\13\n\9end\13\n\13\n\9return optEnergyProduction\13\nend\13\n\13\nfunction grid_controller.getEnergyProductionRateDirect()\13\n\9return grid_controller.getEnergyProductionRateReactorsDirect() + grid_controller.getEnergyProductionRateTurbinesDirect()\13\nend\13\n\13\nfunction grid_controller.getEnergyProductionRateTurbinesDirect()\13\n\9local currentEnergyProduction = 0\13\n\13\n\9for _, turbine in pairs(grid_controller.mTurbinesSorted) do\13\n\9\9currentEnergyProduction = currentEnergyProduction + turbine:getOutputGenerationRate()\13\n\9end\13\n\13\n\9return currentEnergyProduction\13\nend\13\n\13\nfunction grid_controller.getEnergyProductionRateTurbinesMaxDirect()\13\n\9local energyProductionMax = 0\13\n\13\n\9for _, turbine in pairs(grid_controller.mTurbinesSorted) do\13\n\9\9energyProductionMax = energyProductionMax + turbine:getOutputGenerationRateMax()\13\n\9end\13\n\13\n\9return energyProductionMax\13\nend\13\n\13\nfunction grid_controller.getEnergyProductionRateReactorsDirect()\13\n\9local currentEnergyProduction = 0\13\n\13\n\9for _, reactor in pairs(grid_controller.mReactorsSorted) do\13\n\9\9currentEnergyProduction = currentEnergyProduction + reactor:getOutputGenerationRate()\13\n\9end\13\n\13\n\9return currentEnergyProduction\13\nend\13\n\13\nfunction grid_controller.getEnergyProductionRateReactorsMaxDirect()\13\n\9local energyProductionMax = 0\13\n\13\n\9for _, reactor in pairs(grid_controller.mReactorsSorted) do\13\n\9\9energyProductionMax = energyProductionMax + reactor:getOutputGenerationRateMax()\13\n\9end\13\n\13\n\9return energyProductionMax\13\nend\13\n\13\nfunction grid_controller.getEnergyProductionRate()\13\n\9return grid_controller.mStats.energyProductionRate\13\nend\13\n\13\nfunction grid_controller.getEnergyProductionRateReactors()\13\n\9return grid_controller.mStats.energyProductionRateReactors\13\nend\13\n\13\nfunction grid_controller.getEnergyProductionRateReactorsMax()\13\n\9return grid_controller.mStats.energyProductionRateReactorsMax\13\nend\13\n\13\nfunction grid_controller.getEnergyProductionRateTurbines()\13\n\9return grid_controller.mStats.energyProductionRateTurbines\13\nend\13\n\13\nfunction grid_controller.getEnergyProductionRateTurbinesMax()\13\n\9return grid_controller.mStats.energyProductionRateTurbinesMax\13\nend\13\n\13\nfunction grid_controller.getEnergyExtractionRate()\13\n\9return math.max(0, grid_controller.mStats.energyExtractionRate)\13\nend\13\n\13\nfunction grid_controller.getEnergyExtractionRateWeighted()\13\n\9return math.max(0, grid_controller.mStats.energyExtractionRateWeighted)\13\nend\13\n\13\nfunction grid_controller.setChargeMode(enable)\13\n\9checkArg(1, enable, \"boolean\")\13\n\13\n\9grid_controller.mCharge = enable\13\nend\13\n\13\nfunction grid_controller.getChargeMode()\13\n\9return grid_controller.mCharge\13\nend\13\n\13\nfunction grid_controller.getPaused()\13\n\9return grid_controller.mStats.negativeExtractionRateSince > 0 and grid_controller.mStats.negativeExtractionRateSince < 10\13\nend\13\n\13\nfunction grid_controller.runOnce()\13\n\9if not grid_controller.updateStats() then\13\n\9\9return\13\n\9end\13\n\13\n\9-- We need at least SOME energy storage for this to work!\13\n\9if grid_controller.getMaxEnergyStored() <= 0 then\13\n\9\9return\13\n\9end\13\n\13\n\9-- See if we observed some kind of disturbance in the fo...eh.. the power\13\n\9-- grid. If there is, we wait a bit to avoid rapidly turning on and off\13\n\9-- turbines / reactors\13\n\9if grid_controller.getPaused() then\13\n\9\9return\13\n\9end\13\n\13\n\9local energyDemandWeighted = grid_controller.getEnergyExtractionRateWeighted()\13\n\9local energyDemand = grid_controller.getEnergyExtractionRate()\13\n\9local energyRate = grid_controller.getEnergyProductionRate() - energyDemand\13\n\13\n\13\n\9if grid_controller.getChargeMode() and grid_controller.getEnergyStored() >= grid_controller.getMaxEnergyStored() - 60 * grid_controller.getEnergyProductionRate() then\13\n\9\9grid_controller.setChargeMode(false)\13\n\9end\13\n\13\n\9-- When we're producing more energy than required and the energy storage is\13\n\9-- full, the energy extraction rate will clip to the production rate. This\13\n\9-- will cause the controller to never shut down and produce as much energy\13\n\9-- as possible. As a workaround, we force the energy demand to be 0 if the\13\n\9-- energy storage is full. This will cause the controller to shut down\13\n\9-- energy production until the energy storage is not full anymore.\13\n\9-- energyRate is forced to 1the current production rate so runModePWM\13\n\9-- actually does useful things (aka shut down everything).\13\n\9if grid_controller.getEnergyStored() >= grid_controller.getMaxEnergyStored() - grid_controller.getEnergyProductionRate() then\13\n\9\9energyDemand = 0\13\n\9\9energyDemandWeighted = 0\13\n\9\9energyRate = grid_controller.getEnergyProductionRate()\13\n\9end\13\n\13\n\9if energyDemandWeighted > grid_controller.getOptEnergyProduction() then\13\n\9\9if grid_controller.mEnergyStoredTarget == nil then\13\n\9\9\9grid_controller.mEnergyStoredTarget = grid_controller.getEnergyStored()\13\n\9\9end\13\n\9\9grid_controller.mState = controllerState.LOAD\13\n\9\9-- We have to put some reactors into overdrive\13\n\9\9grid_controller.runModeLoad(energyRate, energyDemand, grid_controller.mEnergyStoredTarget)\13\n\9else\13\n\9\9if grid_controller.mEnergyStoredTarget ~= nil then\13\n\9\9\9local energyStoredPercent = grid_controller.getEnergyStored() / grid_controller.getMaxEnergyStored()\13\n\9\9\9if energyStoredPercent >= 0.5 then\13\n\9\9\9\9grid_controller.mState = controllerState.PWM_OFF\13\n\9\9\9else\13\n\9\9\9\9grid_controller.mState = controllerState.PWM_ON\13\n\9\9\9end\13\n\9\9\9grid_controller.mEnergyStoredTarget = nil\13\n\9\9end\13\n\13\n\9\9if grid_controller.getChargeMode() then\13\n\9\9\9grid_controller.runModeCharge()\13\n\9\9else\13\n\9\9\9grid_controller.runModePWM(energyRate, energyDemand)\13\n\9\9end\13\n\9end\13\nend\13\n\13\nfunction grid_controller.runModePWM(energyRate, energyDemand)\13\n\9checkArg(1, energyRate, \"number\")\13\n\9checkArg(2, energyDemand, \"number\")\13\n\13\n\9local energyStored = grid_controller.getEnergyStored()\13\n\9local energyStoredMax = grid_controller.getMaxEnergyStored()\13\n\9local energyStoredPercent = energyStored / energyStoredMax\13\n\13\n\9if energyStoredPercent > grid_controller.mPWMLimitUpper then\13\n\9\9grid_controller.mState = controllerState.PWM_OFF\13\n\9elseif energyStoredPercent < grid_controller.mPWMLimitLower then\13\n\9\9grid_controller.mState = controllerState.PWM_ON\13\n\9end\13\n\13\n\9if energyRate < 0 then\13\n\9\9grid_controller.doPWMIncrease(energyRate, energyDemand, grid_controller.mState == controllerState.PWM_ON)\13\n\9elseif energyRate > 0 then\13\n\9\9grid_controller.doPWMDecrease(energyRate, energyDemand, grid_controller.mState == controllerState.PWM_OFF)\13\n\9end\13\nend\13\n\13\nfunction grid_controller.doPWMDecrease(energyRate, energyDemand, allowNegativeRate)\13\n\9checkArg(1, energyRate, \"number\")\13\n\9checkArg(2, energyDemand, \"number\")\13\n\9checkArg(3, allowNegativeRate, \"boolean\")\13\n\13\n\9local newEnergyRate = energyRate\13\n\9local hasOnlineReactors = false\13\n\9-- See if we can turn off some reactors first\13\n\9for i = #grid_controller.mReactorsSorted, 1, -1 do\13\n\9\9-- Shut down the least efficient reactor that is online\13\n\9\9-- Repeat that for as long as we have reactors left or the energy rate is now negative\13\n\9\9local reactor = grid_controller.mReactorsSorted[i]\13\n\13\n\9\9if newEnergyRate <= 0 or (not allowNegativeRate and newEnergyRate - reactor:getOutputGenerationRate() < 0) then\13\n\9\9\9-- Nothing to do here\13\n\9\9elseif reactor:getOutput() > 0 then\13\n\9\9\9reactor:setOutput(0, 0)\13\n\9\9end\13\n\13\n\9\9-- Always substract the current output because reactors that have been offlined already\13\n\9\9-- are not going to produce any more energy very soon. If this wouldn't be taken into\13\n\9\9-- account the controller would flicker on/off some, if not all, reactors until the\13\n\9\9-- energy rate has stabilized (which might not ever happen because of this).\13\n\9\9if reactor:getOutput() == 0 then\13\n\9\9\9newEnergyRate = newEnergyRate - reactor:getOutputGenerationRate()\13\n\9\9else\13\n\9\9\9hasOnlineReactors = true\13\n\9\9\9-- Check if we need to readjust the reactors output. This may be\13\n\9\9\9-- neccessary if we've just dropped out of LOAD mode\13\n\9\9\9if math.abs(reactor:getOutput() - reactor:getOutputOpt()) > 0.01 then\13\n\9\9\9\9reactor:setOutput(reactor:getOutputOpt(), 0)\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\13\n\9-- Now for turbines...\13\n\9-- If we have online reactors, don't attempt to shut down turbines.\13\n\9for i = #grid_controller.mTurbinesSorted, 1, -1 do\13\n\9\9local turbine = grid_controller.mTurbinesSorted[i]\13\n\13\n\9\9if newEnergyRate <= 0 or (not allowNegativeRate and newEnergyRate - turbine:getOutputGenerationRate() < 0) or hasOnlineReactors then\13\n\9\9\9-- Nothing to do here\13\n\9\9elseif turbine:getState() ~= turbineState.SUSPENDED then\13\n\9\9\9newEnergyRate = newEnergyRate - turbine:getOutputGenerationRate()\13\n\9\9\9turbine:setState(turbineState.SUSPENDED)\13\n\9\9end\13\n\9end\13\n\13\n\9return newEnergyRate\13\nend\13\n\13\nfunction grid_controller.doPWMIncrease(energyRate, energyDemand, allowPositiveRate)\13\n\9checkArg(1, energyRate, \"number\")\13\n\9checkArg(2, energyDemand, \"number\")\13\n\9checkArg(3, allowPositiveRate, \"boolean\")\13\n\13\n\9local newEnergyRate = energyRate\13\n\9local hasSuspendedTurbines = false\13\n\9-- See if we can turn on some turbines first\13\n\9for _, turbine in pairs(grid_controller.mTurbinesSorted) do\13\n\9\9if newEnergyRate >= 0 or (not allowPositiveRate and newEnergyRate + turbine:getOutputGenerationRateMax() > 0) then\13\n\9\9\9-- Nothing to do here\13\n\9\9\9hasSuspendedTurbines = hasSuspendedTurbines or turbine:getState() == turbineState.SUSPENDED\13\n\9\9elseif turbine:getState() == turbineState.SUSPENDED then\13\n\9\9\9newEnergyRate = newEnergyRate + turbine:estimateOutputGenerationRate()\13\n\9\9\9turbine:setState(turbineState.STARTING)\13\n\9\9end\13\n\9end\13\n\13\n\9-- Now for reactors...\13\n\9-- If we have suspended turbines, don't attempt to enable reactors.\13\n\9for _, reactor in pairs(grid_controller.mReactorsSorted) do\13\n\9\9if newEnergyRate >= 0 or (not allowPositiveRate and newEnergyRate + reactor:getCurrentOptimalOutputGenerationRate() > 0) or hasSuspendedTurbines then\13\n\9\9\9-- Nothing to do here\13\n\9\9elseif reactor:getOutput() == 0 then\13\n\9\9\9reactor:setOutput(reactor:getOutputOpt(), 0)\13\n\9\9end\13\n\13\n\9\9-- Check if we need to readjust the reactors output. This may be\13\n\9\9-- neccessary if we've just dropped out of LOAD mode\13\n\9\9if reactor:getOutput() > 0 and math.abs(reactor:getOutput() - reactor:getOutputOpt()) > 0.01 then\13\n\9\9\9reactor:setOutput(reactor:getOutputOpt(), 0)\13\n\9\9end\13\n\13\n\9\9-- We need to consider that reactors take a second or two to get going.\13\n\9\9-- If we didn't do this the controller might flicker on/off some reactors.\13\n\9\9if reactor:getOutput() > 0 and reactor:getOutputGenerationRate() < reactor:getCurrentOptimalOutputGenerationRate() * 0.75 then\13\n\9\9\9newEnergyRate = newEnergyRate + reactor:getCurrentOptimalOutputGenerationRate()\13\n\9\9else\13\n\9\9\9newEnergyRate = newEnergyRate + reactor:getOutputGenerationRate()\13\n\9\9end\13\n\9end\13\n\13\n\9return newEnergyRate\13\nend\13\n\13\n\13\nfunction grid_controller.runModeLoad(energyRate, energyDemand, energyStoredTarget)\13\n\9checkArg(1, energyRate, \"number\")\13\n\9checkArg(2, energyDemand, \"number\")\13\n\9checkArg(3, energyStoredTarget, \"number\")\13\n\13\n\9local newEnergyRate = 0\13\n\13\n\9-- Turn on as many turbines as possible.\13\n\9for _, turbine in pairs(grid_controller.mTurbinesSorted) do\13\n\9\9if newEnergyRate >= energyDemand then\13\n\9\9\9-- Suspend turbines that are not needed.\13\n\9\9\9turbine:setState(turbineState.SUSPENDED)\13\n\9\9elseif turbine:getState() == turbineState.SUSPENDED then\13\n\9\9\9newEnergyRate = newEnergyRate + turbine:estimateOutputGenerationRate()\13\n\9\9\9turbine:setState(turbineState.STARTING)\13\n\9\9else\13\n\9\9\9newEnergyRate = newEnergyRate + turbine:estimateOutputGenerationRate()\13\n\9\9end\13\n\9end\13\n\13\n\9local energyDemandLeft = energyDemand - newEnergyRate\13\n\9local reactorOutputMax = 0\13\n\13\n\9for _, reactor in pairs(grid_controller.mReactorsSorted) do\13\n\9\9reactorOutputMax = reactorOutputMax + reactor:getOutputGenerationRateMax()\13\n\9end\13\n\13\n\9local pTargetEnergyProduction = energyDemandLeft / reactorOutputMax\13\n\9local pEnergyStoredDelta = ( energyStoredTarget - grid_controller.getEnergyStored() ) / grid_controller.getMaxEnergyStored()\13\n\9local pEnergyProductionDelta = 0 - grid_controller.getEnergyStoredRate() / reactorOutputMax\13\n\13\n\9for _, reactor in pairs(grid_controller.mReactorsSorted) do\13\n\9\9reactor:regulatePD2(pTargetEnergyProduction, pEnergyStoredDelta, pEnergyProductionDelta)\13\n\9end\13\n\13\n\9-- TODO: estimate actual energy production\13\n\9return energyDemand\13\nend\13\n\13\nfunction grid_controller.runModeCharge()\13\n\9local newEnergyRate = 0\13\n\13\n\9for _, turbine in pairs(grid_controller.mTurbinesSorted) do\13\n\9\9if turbine:getState() == turbineState.SUSPENDED then\13\n\9\9\9newEnergyRate = newEnergyRate + turbine:estimateOutputGenerationRate()\13\n\9\9\9turbine:setState(turbineState.STARTING)\13\n\9\9else\13\n\9\9\9newEnergyRate = newEnergyRate + turbine:estimateOutputGenerationRate()\13\n\9\9end\13\n\9end\13\n\13\n\9for _, reactor in pairs(grid_controller.mReactorsSorted) do\13\n\9\9if reactor:getOutput() ~= reactor:getOutputOpt() then\13\n\9\9\9reactor:setOutput(reactor:getOutputOpt(), 0)\13\n\9\9end\13\n\13\n\9\9newEnergyRate = newEnergyRate + reactor:getOutputGenerationRate()\13\n\9end\13\n\13\n\9return newEnergyRate\13\nend\13\n\13\n-- Storage functions\13\n\13\nfunction grid_controller.discoverStorage()\13\n\9-- Loop over the types of supported energy storage components\13\n\9for typeID, _ in pairs(energy_storage_component.mCompatibleComponents) do\13\n\9\9local br_components = component.list(typeID)\13\n\9\9-- Add all addresses for the current component. If the component\13\n\9\9-- already exists, nothing happens.\13\n\9\9for address, _ in pairs(br_components) do\13\n\9\9\9grid_controller.addStorage(address)\13\n\9\9end\13\n\9end\13\nend\13\n\13\nfunction grid_controller.addStorage(address)\13\n\9checkArg(1, address, \"string\")\13\n\13\n\9if grid_controller.mEnergyStorage[address] == nil then\13\n\9\9local new_storage = energy_storage_component(address)\13\n\13\n\9\9if new_storage:isGood() then\13\n\9\9\9new_storage:update()\13\n\9\9\9grid_controller.mEnergyStorage[address] = new_storage\13\n\9\9\9computer.pushSignal(\"brgc_storage_added\", address)\13\n\9\9end\13\n\9end\13\nend\13\n\13\nfunction grid_controller.removeStorage(address)\13\n\9checkArg(1, address, \"string\")\13\n\13\n\9if grid_controller.mEnergyStorage[address] ~= nil then\13\n\9\9grid_controller.mEnergyStorage[address] = nil\13\n\9\9computer.pushSignal(\"brgc_storage_removed\", address)\13\n\9end\13\nend\13\n\13\n-- Service functions\13\n\13\nfunction grid_controller.start()\13\n\9if grid_controller.mTimerId ~= nil then\13\n\9\9return false\13\n\9else\13\n\9\9event.listen(\"component_added\", grid_controller.asyncComponentAddedHandler)\13\n\9\9event.listen(\"component_removed\", grid_controller.asyncComponentRemovedHandler)\13\n\9\9grid_controller.mTimerId = event.timer(1, grid_controller.asyncTimerHandler, math.huge)\13\n\9\9return true\13\n\9end\13\nend\13\n\13\nfunction grid_controller.stop()\13\n\9if grid_controller.mTimerId == nil then\13\n\9\9return false\13\n\9else\13\n\9\9event.ignore(\"component_added\", grid_controller.asyncComponentAddedHandler)\13\n\9\9event.ignore(\"component_removed\", grid_controller.asyncComponentRemovedHandler)\13\n\9\9event.cancel(grid_controller.mTimerId)\13\n\9\9grid_controller.mTimerId = nil\13\n\9\9return true\13\n\9end\13\nend\13\n\13\nfunction grid_controller.isRunning()\13\n\9return grid_controller.mTimerId ~= nil\13\nend\13\n\13\nfunction grid_controller.asyncComponentAddedHandler(eventID, address, typeID)\13\n\9if energy_storage_component.isCompatible(typeID) then\13\n\9\9grid_controller.addStorage(address)\13\n\9end\13\nend\13\n\13\nfunction grid_controller.asyncComponentRemovedHandler(eventID, address, typeID)\13\n\9if energy_storage_component.isCompatible(typeID) then\13\n\9\9grid_controller.removeStorage(address)\13\n\9end\13\nend\13\n\13\nfunction grid_controller.asyncTimerHandler()\13\n\9xpcall(grid_controller.runOnce, function(...) io.stderr:write(debug.traceback(...) .. \"\\n\") end)\13\nend\13\n\13\nreturn grid_controller\13\n",["/usr/lib/brgc/turbine_factory.lua"]="local config = require(\"brgc/config\")\13\nlocal turbine_base = require(\"brgc/turbine\")\13\n\13\nlocal turbine_factory = {\13\n\13\n}\13\n\13\n\13\nfunction turbine_factory:make(turbineAddress)\13\n\9checkArg(1, turbineAddress, \"string\")\13\n\13\n\9local turbineConfig = config.getTurbineConfigOrDefault(turbineAddress)\13\n\9assert(turbineConfig ~= nil, \"Failed to get turbine configuration\")\13\n\13\n\9local turbine = turbine_base(turbineAddress, turbineConfig)\13\n\13\n\9if not turbine:connect() then\13\n\9\9return nil\13\n\9end\13\n\13\n\9return turbine\13\nend\13\n\13\nsetmetatable(turbine_factory, { __call = turbine_factory.make })\13\n\13\nreturn turbine_factory",["/usr/lib/brgc/reactor_factory.lua"]="local config = require(\"brgc/config\")\13\nlocal component = require(\"component\")\13\nlocal reactor_active = require(\"brgc/reactor_active\")\13\nlocal reactor_passive = require(\"brgc/reactor_passive\")\13\n\13\nlocal reactor_factory = {\13\n\13\n}\13\n\13\n\13\nfunction reactor_factory:make(reactorAddress)\13\n\9checkArg(1, reactorAddress, \"string\")\13\n\13\n\9local reactorConfig = config.getReactorConfigOrDefault(reactorAddress)\13\n\9assert(reactorConfig ~= nil, \"Failed to get reactor configuration\")\13\n\13\n\9local reactor_proxy = component.proxy(reactorAddress)\13\n\9local reactor\13\n\9if reactor_proxy.isActivelyCooled() then\13\n\9\9reactor = reactor_active(reactorAddress, reactorConfig)\13\n\9else\13\n\9\9reactor = reactor_passive(reactorAddress, reactorConfig)\13\n\9end\13\n\13\n\9if not reactor:connect() then\13\n\9\9return nil\13\n\9end\13\n\13\n\9reactor:recalculateOpts()\13\n\13\n\9return reactor\13\nend\13\n\13\nsetmetatable(reactor_factory, { __call = reactor_factory.make })\13\n\13\nreturn reactor_factory",["/usr/bin/brgcctrl.lua"]="local shell = require(\"shell\")\13\nlocal reactor_ctrl = require(\"brgc/reactor_ctrl\")\13\nlocal turbine_ctrl = require(\"brgc/turbine_ctrl\")\13\nlocal grid_ctrl = require(\"brgc/grid_controller\")\13\nlocal turbineState = require(\"brgc/turbine_state\")\13\nlocal reactorState = require(\"brgc/reactor_state\")\13\nlocal brgc_config = require(\"brgc/config\")\13\n\13\nlocal g_modules = { }\13\n\13\nlocal function get_component_by_partial_address(partialAddress, includeReactors, includeTurbines)\13\n\9local maps = { }\13\n\9if includeReactors then\13\n\9\9table.insert(maps, reactor_ctrl.mReactors)\13\n\9end\13\n\9if includeTurbines then\13\n\9\9table.insert(maps, turbine_ctrl.mTurbines)\13\n\9end\13\n\13\n\9local selectedComponent = nil\13\n\9for _, v in pairs(maps) do\13\n\9\9for componentAddress, component in pairs(v) do\13\n\9\9\9if string.sub(componentAddress, 1, string.len(partialAddress)) == partialAddress then\13\n\9\9\9\9if selectedComponent == nil then\13\n\9\9\9\9\9selectedComponent = component\13\n\9\9\9\9else\13\n\9\9\9\9\9return nil\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\9return selectedComponent\13\nend\13\n\13\nlocal function print_submodules(module, stderr)\13\n\9for key, value in pairs(module) do\13\n\9\9local meta = getmetatable(value)\13\n\9\9if not stderr then\13\n\9\9\9io.write(\" - \" .. tostring(key) .. \"\\n\")\13\n\9\9\9if meta.__description then\13\n\9\9\9\9io.write(\"   \" .. tostring(meta.__description) .. \"\\n\")\13\n\9\9\9end\13\n\9\9else\13\n\9\9\9io.stderr:write(\" - \" .. tostring(key) .. \"\\n\")\13\n\9\9\9if meta.__description then\13\n\9\9\9\9io.stderr:write(\"   \" .. tostring(meta.__description) .. \"\\n\")\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function list_turbines()\13\n\9for turbineAddress, turbine in pairs(turbine_ctrl.mTurbines) do\13\n\9\9io.write(\13\n\9\9\9string.format(\"%s  %13s  %6d RF/t  %4d RPM\\n\", turbineAddress, turbineState.toString(turbine:getState()), math.floor(turbine:getOutputGenerationRate() + 0.5), math.floor(turbine:getRPM() + 0.5))\13\n\9\9)\13\n\9end\13\nend\13\n\13\nlocal function list_reactors()\13\n\9for reactorAddress, reactor in pairs(reactor_ctrl.mReactors) do\13\n\9\9if reactor:isActivelyCooled() then\13\n\9\9\9io.write(\13\n\9\9\9\9string.format(\"%s  %13s  %6d mB/t\\n\", reactorAddress, reactorState.toString(reactor:getState()), math.floor(reactor:getOutputGenerationRate() + 0.5))\13\n\9\9\9)\13\n\9\9else\13\n\9\9\9io.write(\13\n\9\9\9\9string.format(\"%s  %13s  %6d RF/t\\n\", reactorAddress, reactorState.toString(reactor:getState()), math.floor(reactor:getOutputGenerationRate() + 0.5))\13\n\9\9\9)\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function print_help()\13\n\9io.write(\"Usage: brctrl <modules...>\\n\")\13\n\9io.write(\"\\n\")\13\n\9print_submodules(g_modules)\13\nend\13\n\13\ng_modules = {\13\n\9__call = print_help,\13\n\9help = {\13\n\9\9__call = print_help,\13\n\9\9__description = \"Usage: brctrl help <module>\\n   \" ..\13\n\9\9\9\9\9\9\"Display help for the given module\"\13\n\9}, -- help = { ... }\13\n\13\n\9service = {\13\n\9\9reactor = {\13\n\9\9\9start = {\13\n\9\9\9\9__call = function()\13\n\9\9\9\9\9if reactor_ctrl.isRunning() then\13\n\9\9\9\9\9\9io.stderr:write(\"Big Reactors Grid Control - Reactor Controller service already running.\\n\")\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9reactor_ctrl.discover()\13\n\9\9\9\9\9\9reactor_ctrl.start()\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\9\9\9},\13\n\9\9\9stop = {\13\n\9\9\9\9__call = function()\13\n\9\9\9\9\9if not reactor_ctrl.isRunning() then\13\n\9\9\9\9\9\9io.stderr:write(\"Big Reactors Grid Control - Reactor Controller service not running.\\n\")\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9reactor_ctrl.stop()\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\9\9\9},\13\n\9\9\9restart = {\13\n\9\9\9\9__call = function()\13\n\9\9\9\9\9reactor_ctrl.reset()\13\n\9\9\9\9\9reactor_ctrl.discover()\13\n\9\9\9\9\9if not reactor_ctrl.isRunning() then\13\n\9\9\9\9\9\9reactor_ctrl.start()\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\9\9\9},\13\n\9\9\9status = {\13\n\9\9\9\9__call = function()\13\n\9\9\9\9\9if reactor_ctrl.isRunning() then\13\n\9\9\9\9\9\9io.write(\"Big Reactors Grid Control - Reactor Controller is running.\\n\")\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9io.write(\"Big Reactors Grid Control - Reactor Controller is not running.\\n\")\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\9\9\9},\13\n\9\9\9shutdown = {\13\n\9\9\9\9__call = reactor_ctrl.shutdown\13\n\9\9\9},\13\n\9\9\9runOnce = {\13\n\9\9\9\9__call = reactor_ctrl.runOnce\13\n\9\9\9}\13\n\9\9}, -- reactor = { ... }\13\n\13\n\9\9turbine = {\13\n\9\9\9start = {\13\n\9\9\9\9__call = function()\13\n\9\9\9\9\9if turbine_ctrl.isRunning() then\13\n\9\9\9\9\9\9io.stderr:write(\"Big Reactors Grid Control - Turbine Controller service already running.\\n\")\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9turbine_ctrl.discover()\13\n\9\9\9\9\9\9turbine_ctrl.start()\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\9\9\9},\13\n\9\9\9stop = {\13\n\9\9\9\9__call = function()\13\n\9\9\9\9\9if not turbine_ctrl.isRunning() then\13\n\9\9\9\9\9\9io.stderr:write(\"Big Reactors Grid Control - Turbine Controller service not running.\\n\")\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9turbine_ctrl.stop()\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\9\9\9},\13\n\9\9\9restart = {\13\n\9\9\9\9__call = function()\13\n\9\9\9\9\9turbine_ctrl.reset()\13\n\9\9\9\9\9turbine_ctrl.discover()\13\n\9\9\9\9\9if not turbine_ctrl.isRunning() then\13\n\9\9\9\9\9\9turbine_ctrl.start()\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\9\9\9},\13\n\9\9\9status = {\13\n\9\9\9\9__call = function()\13\n\9\9\9\9\9if turbine_ctrl.isRunning() then\13\n\9\9\9\9\9\9io.write(\"Big Reactors Grid Control - Turbine Controller is running.\\n\")\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9io.write(\"Big Reactors Grid Control - Turbine Controller is not running.\\n\")\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\9\9\9},\13\n\9\9\9shutdown = {\13\n\9\9\9\9__call = turbine_ctrl.shutdown\13\n\9\9\9},\13\n\9\9\9runOnce = {\13\n\9\9\9\9__call = turbine_ctrl.runOnce\13\n\9\9\9}\13\n\9\9}, -- turbine = { ... }\13\n\13\n\9\9grid = {\13\n\9\9\9start = {\13\n\9\9\9\9__call = function()\13\n\9\9\9\9\9if grid_ctrl.isRunning() then\13\n\9\9\9\9\9\9io.stderr:write(\"Big Reactors Grid Control - Grid Controller service already running.\\n\")\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9grid_ctrl.discoverStorage()\13\n\9\9\9\9\9\9grid_ctrl.start()\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\9\9\9},\13\n\9\9\9stop = {\13\n\9\9\9\9__call = function()\13\n\9\9\9\9\9if not grid_ctrl.isRunning() then\13\n\9\9\9\9\9\9io.stderr:write(\"Big Reactors Grid Control - Grid Controller service not running.\\n\")\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9grid_ctrl.stop()\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\9\9\9},\13\n\9\9\9restart = {\13\n\9\9\9\9__call = function()\13\n\9\9\9\9\9grid_ctrl.reset()\13\n\9\9\9\9\9grid_ctrl.discoverStorage()\13\n\9\9\9\9\9if not grid_ctrl.isRunning() then\13\n\9\9\9\9\9\9grid_ctrl.start()\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\9\9\9},\13\n\9\9\9status = {\13\n\9\9\9\9__call = function()\13\n\9\9\9\9\9if grid_ctrl.isRunning() then\13\n\9\9\9\9\9\9io.write(\"Big Reactors Grid Control - Grid Controller is running.\\n\")\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9io.write(\"Big Reactors Grid Control - Grid Controller is not running.\\n\")\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\9\9\9},\13\n\9\9\9runOnce = {\13\n\9\9\9\9__call = grid_ctrl.runOnce\13\n\9\9\9}\13\n\9\9}, -- grid = { ... }\13\n\13\n\9\9all = {\13\n\9\9\9start = {\13\n\9\9\9\9__call = function()\13\n\9\9\9\9\9g_modules.service.reactor.start()\13\n\9\9\9\9\9g_modules.service.turbine.start()\13\n\9\9\9\9\9g_modules.service.grid.start()\13\n\9\9\9\9end\13\n\9\9\9},\13\n\9\9\9stop = {\13\n\9\9\9\9__call = function()\13\n\9\9\9\9\9g_modules.service.grid.stop()\13\n\9\9\9\9\9g_modules.service.turbine.stop()\13\n\9\9\9\9\9g_modules.service.reactor.stop()\13\n\9\9\9\9end\13\n\9\9\9},\13\n\9\9\9restart = {\13\n\9\9\9\9__call = function()\13\n\9\9\9\9\9g_modules.service.reactor.restart()\13\n\9\9\9\9\9g_modules.service.turbine.restart()\13\n\9\9\9\9\9g_modules.service.grid.restart()\13\n\9\9\9\9end\13\n\9\9\9},\13\n\9\9\9shutdown = {\13\n\9\9\9\9__call = function()\13\n\9\9\9\9\9g_modules.service.turbine.shutdown()\13\n\9\9\9\9\9g_modules.service.reactor.shutdown()\13\n\9\9\9\9end\13\n\9\9\9}\13\n\9\9} -- all = { ... }\13\n\9}, -- service = { ... }\13\n\13\n\9list = {\13\n\9\9__call = function(context, args)\13\n\9\9\9assert(#args == 0, \"This method has no arguments.\\n\")\13\n\9\9\9io.write(\"Reactors\\n\")\13\n\9\9\9list_reactors()\13\n\9\9\9io.write(\"\\nTurbines\\n\")\13\n\9\9\9list_turbines()\13\n\9\9end,\13\n\13\n\9\9reactors = {\13\n\9\9\9__call = list_reactors\13\n\9\9},\13\n\13\n\9\9turbines = {\13\n\9\9\9__call = list_turbines\13\n\9\9}\13\n\9}, -- list = { ... }\13\n\13\n\9discover = {\13\n\9\9__call = function(context, args)\13\n\9\9\9assert(#args == 0, \"This method has no arguments.\\n\")\13\n\9\9\9reactor_ctrl.discover()\13\n\9\9\9turbine_ctrl.discover()\13\n\9\9end,\13\n\13\n\9\9reactors = {\13\n\9\9\9__call = reactor_ctrl.discover\13\n\9\9},\13\n\13\n\9\9turbines = {\13\n\9\9\9__call = turbine_ctrl.discover\13\n\9\9}\13\n\9}, -- discover = { ... }\13\n\13\n\9steamtarget = {\13\n\9\9get = {\13\n\9\9\9__call = function()\13\n\9\9\9\9io.write(\13\n\9\9\9\9\9string.format(\"Current steam production target: %d mB/t\\n\", reactor_ctrl.getSteamProductionTarget() )\13\n\9\9\9\9)\13\n\9\9\9end\13\n\9\9},\13\n\13\n\9\9set = {\13\n\9\9\9__call = function(context, args)\13\n\9\9\9\9assert(#args == 1, \"This method requires exactly one argument\")\13\n\9\9\9\9local steamtarget = tonumber(args[1])\13\n\9\9\9\9assert(tostring(steamtarget) == args[1], \"This method requires a non-negative number as argument\")\13\n\9\9\9\9assert(steamtarget >= 0, tostring(steamtarget) .. \" is not a non-negative number\")\13\n\9\9\9\9reactor_ctrl.setSteamProductionTarget(steamtarget)\13\n\9\9\9end\13\n\9\9}\13\n\9}, -- steamtarget = { ... }\13\n\13\n\9config = {\13\n\9\9reactor = {\13\n--\9\9\9__args = 1,\13\n\9\9\9get = {\13\n\9\9\9\9__call = function(context, args)\13\n\9\9\9\9\9assert(#args == 1 or #args == 2, \"This method requires exactly one or two arguments:\\nbrgcctrl config reactor <partial address> get [<property>]\")\13\n\9\9\9\9\9local reactor = get_component_by_partial_address(args[1], true, false)\13\n\9\9\9\9\9assert(reactor ~= nil, \"No reactor can be uniquely identified by '\" .. tostring(args[1]) .. \"'\")\13\n\9\9\9\9\9local reactor_config = brgc_config:getReactorConfig(reactor:getAddress())\13\n\9\9\9\9\9if reactor_config == nil then\13\n\9\9\9\9\9\9io.write(\"Note: No configuration found for reactor '\" .. reactor:getAddress() .. \"'. Using defaults.\\n\")\13\n\9\9\9\9\9\9reactor_config = brgc_config:getDefaultReactorConfig()\13\n\9\9\9\9\9end\13\n\9\9\9\9\9if #args == 2 then\13\n\9\9\9\9\9\9io.write(tostring(args[2]) .. \" = \" .. tostring(reactor_config[args[2]]) .. \"\\n\")\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9for key, value in pairs(reactor_config) do\13\n\9\9\9\9\9\9\9io.write(tostring(key) .. \" = \" .. tostring(value) .. \"\\n\")\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\9\9\9}, -- reactor::get()\13\n\9\9\9set = {\13\n\9\9\9\9__call = function(context, args)\13\n\9\9\9\9\9assert(#args == 3, \"This method requires exactly three arguments:\\nbrgcctrl config reactor <partial address> set <property> <value>\")\13\n\9\9\9\9\9local reactor = get_component_by_partial_address(args[1], true, false)\13\n\9\9\9\9\9assert(reactor ~= nil, \"No reactor can be uniquely identified by '\" .. tostring(args[1]) .. \"'\")\13\n\9\9\9\9\9local value = nil\13\n\9\9\9\9\9if args[3] == \"nil\" then\13\n\9\9\9\9\9elseif tostring(tonumber(args[3])) == args[3] then\13\n\9\9\9\9\9\9value = tonumber(args[3])\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9value = args[3]\13\n\9\9\9\9\9end\13\n\9\9\9\9\9brgc_config:setReactorAttribute(reactor:getAddress(), args[2], value)\13\n\9\9\9\9end\13\n\9\9\9}, -- reactor::set()\13\n\9\9\9commit = {\13\n\9\9\9\9__call = reactor_ctrl.reload\13\n\9\9\9} -- reactor::commit()\13\n\9\9}, -- reactor = { ... }\13\n\9\9turbine = {\13\n--\9\9\9__args = 1,\13\n\9\9\9get = {\13\n\9\9\9\9__call = function(context, args)\13\n\9\9\9\9\9assert(#args == 1 or #args == 2, \"This method requires exactly one or two arguments:\\nbrgcctrl config turbine <partial address> get [<property>]\")\13\n\9\9\9\9\9local turbine = get_component_by_partial_address(args[1], false, true)\13\n\9\9\9\9\9assert(turbine ~= nil, \"No turbine can be uniquely identified by '\" .. tostring(args[1]) .. \"'\")\13\n\9\9\9\9\9local turbine_config = brgc_config:getTurbineConfig(turbine:getAddress())\13\n\9\9\9\9\9if turbine_config == nil then\13\n\9\9\9\9\9\9io.write(\"Note: No configuration found for turbine '\" .. turbine:getAddress() .. \"'. Using defaults.\\n\")\13\n\9\9\9\9\9\9turbine_config = brgc_config:getDefaultTurbineConfig()\13\n\9\9\9\9\9end\13\n\9\9\9\9\9if #args == 2 then\13\n\9\9\9\9\9\9io.write(tostring(args[2]) .. \" = \" .. tostring(turbine_config[args[2]]) .. \"\\n\")\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9for key, value in pairs(turbine_config) do\13\n\9\9\9\9\9\9\9io.write(tostring(key) .. \" = \" .. tostring(value) .. \"\\n\")\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\9\9\9}, -- turbine::get()\13\n\9\9\9set = {\13\n\9\9\9\9__call = function(context, args)\13\n\9\9\9\9\9assert(#args == 3, \"This method requires exactly three arguments:\\nbrgcctrl config turbine <partial address> set <property> <value>\")\13\n\9\9\9\9\9local turbine = get_component_by_partial_address(args[1], false, true)\13\n\9\9\9\9\9assert(turbine ~= nil, \"No turbine can be uniquely identified by '\" .. tostring(args[1]) .. \"'\")\13\n\9\9\9\9\9local value = nil\13\n\9\9\9\9\9if args[3] == \"nil\" then\13\n\9\9\9\9\9elseif tostring(tonumber(args[3])) == args[3] then\13\n\9\9\9\9\9\9value = tonumber(args[3])\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9value = args[3]\13\n\9\9\9\9\9end\13\n\9\9\9\9\9brgc_config:setTurbineAttribute(turbine:getAddress(), args[2], value)\13\n\9\9\9\9end\13\n\9\9\9}, -- turbine::set()\13\n\9\9\9commit = {\13\n\9\9\9\9__call = turbine_ctrl.reload\13\n\9\9\9} -- turbine::commit()\13\n\9\9}, -- turbine = { ... }\13\n\9\9commit = {\13\n\9\9\9__call = function(context, args)\13\n\9\9\9\9assert(#args == 0, \"This method has no arguments.\\n\")\13\n\9\9\9\9reactor_ctrl.reload()\13\n\9\9\9\9turbine_ctrl.reload()\13\n\9\9\9end\13\n\9\9} -- commit = { ... }\13\n\9}, -- config = { ... }\13\n\13\n\9calibrate = {\13\n\9\9__call = function(context, args)\13\n\9\9\9assert(#args == 1, \"This method requires exactly one argument:\\nbrgcctrl calibrate <partial address>\")\13\n\9\9\9local component = get_component_by_partial_address(args[1], true, true)\13\n\9\9\9assert(component ~= nil, \"No component can be uniquely identified by '\" .. tostring(args[1]) .. \"'\")\13\n\9\9\9component:recalibrate()\13\n\9\9end\13\n\9} -- calibrate = { ... }\13\n}\13\n\13\n\13\nlocal function convert_context_table(t)\13\n\9local meta = getmetatable(t) or { }\13\n\9local remove = {}\13\n\9for key, value in pairs(t) do\13\n\9\9if string.sub(key, 1, 2) == \"__\" then\13\n\9\9\9meta[key] = value\13\n\9\9\9table.insert(remove, key)\13\n\9\9elseif type(value) == \"table\" then\13\n\9\9\9convert_context_table(value)\13\n\9\9end\13\n\9end\13\n\9for _, key in pairs(remove) do\13\n\9\9t[key] = nil\13\n\9end\13\n\9if meta.__call == nil then\13\n\9\9meta.__call = function(context)\13\n\9\9\9io.write(\"The following modules are available in the current context:\\n\")\13\n\9\9\9print_submodules(context)\13\n\9\9end\13\n\9end\13\n\9setmetatable(t, meta)\13\nend\13\n\13\nconvert_context_table(g_modules)\13\n\13\nlocal args = shell.parse(...)\13\nlocal currentContext = g_modules\13\nlocal contextArgs = {}\13\n\13\nwhile #args > 0 do\13\n\9local nextModuleName = table.remove(args, 1)\13\n\9local nextContext = currentContext[nextModuleName]\13\n\9if nextContext == nil then\13\n\9\9io.stderr:write(\"The selected module '\" .. tostring(nextModuleName) .. \"' could not be found.\\n\")\13\n\9\9io.stderr:write(\"The following modules are available in the current context:\\n\")\13\n\9\9for key, _ in pairs(currentContext) do\13\n\9\9\9io.stderr:write(\" - \" .. tostring(key) .. \"\\n\")\13\n\9\9end\13\n\9\9io.stderr:write(\"\\n\")\13\n\9\9return false\13\n\9else\13\n\9\9currentContext = nextContext\13\n\9\9if next(nextContext) ~= nil then\13\n\9\9\9local meta = getmetatable(currentContext)\13\n\9\9\9local i = 1\13\n\9\9\9while #args > 0 and i <= (meta.__args or 0) do\13\n\9\9\9\9table.insert(contextArgs, table.remove(args, 1))\13\n\9\9\9\9i = i + 1\13\n\9\9\9end\13\n\9\9\9if i < (meta.__args or 0)+1 then\13\n\9\9\9\9io.stderr:write(\"Module '\" .. tostring(nextModuleName) .. \"' expects \" .. tostring(meta.__args or 0) .. \" arguments. \" .. tostring(i-1) .. \" given.\\n\")\13\n\9\9\9\9return false\13\n\9\9\9end\13\n\9\9else\13\n\9\9\9break\13\n\9\9end\13\n\9end\13\nend\13\n\13\nwhile #args > 0 do\13\n\9table.insert(contextArgs, table.remove(args, 1))\13\nend\13\n\13\nlocal success, errorMessage = xpcall(function() currentContext(contextArgs) end, debug.traceback)\13\nif not success then\13\n\9io.stderr:write(\"An error occurred during context execution:\\n\")\13\n\9io.stderr:write(errorMessage .. \"\\n\")\13\n\9return false\13\nend\13\n\13\nreturn true\13\n",["/usr/lib/brgc/reactor_active.lua"]="local oop = require(\"oop\")\nlocal promise = require(\"promise\")\nlocal config_api = require(\"brgc/config\")\nlocal reactor_base = require(\"brgc/reactor_base\")\nlocal reactorState = require(\"brgc/reactor_state\")\nlocal polynomial_iterpolator = require(\"polynomial_iterpolator\")\nlocal polynomial = require(\"polynomial\")\n\nlocal reactor_active = {\n\9mSteamProductionTarget = 0\n}\noop.inherit(reactor_active, reactor_base)\n\nfunction reactor_active:construct(address, config)\n\9reactor_base.construct(self, address, config)\nend\n\nfunction reactor_active:init()\n\9self:setOutput(self.mSteamProductionTarget)\nend\n\nfunction reactor_active:getOutputStats()\n\9if self.mComponent.getHotFluidStats then\n\9\9local stats = self.mComponent.getHotFluidStats()\n\9\9return {\n\9\9\9outputStored = stats.fluidAmount,\n\9\9\9outputCapacity = stats.fluidCapacity,\n\9\9\9outputProducedLastTick = stats.fluidProducedLastTick\n\9\9}\n\9else\n\9\9return {\n\9\9\9outputStored = self.mComponent.getHotFluidAmount(),\n\9\9\9outputCapacity = self.mComponent.getHotFluidAmountMax(),\n\9\9\9outputProducedLastTick = self.mComponent.getHotFluidProducedLastTick()\n\9\9}\n\9end\nend\n\nfunction reactor_active:setSteamProductionTarget(steamtarget)\n\9self.mSteamProductionTarget = steamtarget\n\9self:setOutput(steamtarget / self:getOutputGenerationRateMax())\nend\n\nfunction reactor_active:regulate()\n\9local steamStored = self:getOutputStored()\n\9local steamProduced = self:getOutputGenerationRate()\n\9--[[\n\9local steamStoredTarget = math.min(\n\9\9self.mComponent.getCoolantAmount() - steamProduced / 2,\n\9\0093 * (self:getOutputStoredMax() - steamProduced) / 4\n\9) --math.min(self:getOutputStoredMax() - steamProduced * 1.1, self:getOutputStoredMax() / 4 * 3)\n\9--]]\n\9-- local steamStoredTarget = (self:getOutputStoredMax() - steamProduced*2)/2\n\9--[[\n\9\9local steamStoredTarget = math.min(\n\9\9\9self:getOutputStoredMax() - steamProduced * 1.1,\n\9\9\9self:getOutputStoredMax() / 4 * 3\n\9\9)\n\9--]]\n\9local steamStoredTarget = self:getOutputStoredMax() / 2\n\9if steamProduced > steamStoredTarget then\n\9\9steamStoredTarget = (self:getOutputStoredMax() - steamProduced*2)/2\n\9end\n\9local steamStoredDelta = steamStoredTarget - steamStored\n\n\9local pSteamStoredDelta = steamStoredDelta / self:getOutputStoredMax()\n\9local pSteamProductionDelta = 0-self:getOutputStoredRate() / self:getOutputGenerationRateMax()\n\9local pTemperatureLimit = 0-math.max(0, math.pow(1.5, (self:getFuelTemperature() - 700)/100) - 1) * 0.1\n\n\9local steamOffset = pSteamStoredDelta * 0.15 + pSteamProductionDelta * 0.35 + pTemperatureLimit\n--\9local steamOffset = pSteamStoredDelta * 0.007 + pSteamProductionDelta * 0.35 + pTemperatureLimit\n\9if steamStored + steamProduced >= self:getOutputStoredMax() * 0.99 then\n\9\9steamOffset = self:getOutputOffset() - 0.01\n\9end\n\n--[[\n\9print(\n\9\9\"steamStored = \" .. steamStored ..\n\9\9\" steamProduced = \" .. steamProduced ..\n\9\9\" pSteamStoredDelta = \" .. pSteamStoredDelta ..\n\9\9\" pSteamProductionDelta = \" .. pSteamProductionDelta ..\n\9\9\" pTemperatureLimit = \" .. pTemperatureLimit ..\n\9\9\" steamOffset = \" .. steamOffset ..\n\9\9\" steamStoredTarget = \" .. steamStoredTarget\n\9)\n]]--\n\9self:setOutputOffset(steamOffset)\nend\n\nfunction reactor_active:isGood()\n\9local temperature = self:getFuelTemperature()\n\9local coolantThreshold = self:getOutputGenerationRate()\n\9local steamThreshold = self:getOutputStoredMax() - coolantThreshold\n\n\9return (temperature < 1500) and (self.mComponent.getCoolantAmount() >= coolantThreshold) and (self:getOutputStored() < steamThreshold)\nend\n\nfunction reactor_active:finalizeCalibration()\n\9local calibrationValue = 0\n\9local rodLevelMin = math.min(100, math.max(0, self.mReactorConfig.rodLevelMin or 0))\n\n\9if #self.mCalibrationData == 0 or rodLevelMin >= 100 then\n\9\9self:setState(reactorState.ERROR)\n\9\9return\n\9end\n\n\9for _,value in pairs(self.mCalibrationData) do\n\9\9calibrationValue = calibrationValue + value.value/value.load\n\9end\n\9calibrationValue = calibrationValue / #self.mCalibrationData * (100-rodLevelMin)/100\n\n\9local estMinRodInsertion = rodLevelMin/100\n\9local curMinRodInsertion = rodLevelMin/100\n\9local steamTankMax = self:getOutputStoredMax()\n\n\9if calibrationValue > steamTankMax then\n\9\9estMinRodInsertion = (1 - steamTankMax / calibrationValue)\n\9\9calibrationValue = steamTankMax\n\9end\n\n\9if curMinRodInsertion > estMinRodInsertion then\n\9\9calibrationValue = calibrationValue / (1-estMinRodInsertion) * (1-curMinRodInsertion)\n\9\9estMinRodInsertion = curMinRodInsertion\n\9end\n\n\9local efficiency_samples = {}\n\9for _, data in pairs(self.mCalibrationData) do\n\9\9table.insert(efficiency_samples, {\n\9\9\9data.load / (1-estMinRodInsertion),\n\9\9\9data.efficiency\n\9\9})\n\9end\n\n\9self:setState(reactorState.OFFLINE)\n\9promise(function()\n\9\9local poly_efficiency = polynomial_iterpolator.interpolate(efficiency_samples, math.min(5, #efficiency_samples - 1))\n\n\9\9return poly_efficiency\n\9end):after(function(reactor, poly_efficiency)\n\9\9reactor.mReactorConfig.rodLevelMin = estMinRodInsertion * 100\n\9\9reactor.mReactorConfig.outputPoly = polynomial.make({0, calibrationValue})\n\9\9reactor.mReactorConfig.outputReversePoly = polynomial.make({0, 1 / calibrationValue})\n\9\9reactor.mReactorConfig.outputOpt = math.max(0.01, math.min(1, poly_efficiency:converge(0, 10)))\n\9\9reactor:recalculateOpts()\n\9end, self):catch(function(reactor)\n\9\9if reactor:isConnected() then\n\9\9\9reactor:setState(reactorState.ERROR)\n\9\9end\n\9end, self):finally(function(reactor)\n\9\9reactor.mCalibrationData = nil\n\9\9reactor.mCalibrationStep = nil\n\9\9reactor.mCalibrationValueLast = nil\n\n\9\9if reactor:getState() ~= reactorState.ERROR then\n\9\9\9config_api.setReactor(reactor:getAddress(), reactor.mReactorConfig)\n\n\9\9\9if reactor:isConnected() then\n\9\9\9\9reactor:setOutput(0, 0)\n\9\9\9\9reactor:setState(reactorState.ONLINE)\n\9\9\9end\n\9\9end\n\9end, self)\nend\n\n\nreturn reactor_active",["/etc/rc.d/brgc_grid.lua"]="--[[\13\nInit script for Big Reactors Grid Control - Grid Controller for OpenComputers by XyFreak\13\nWebsite: http://tenyx.de/brgc/\13\n--]]\13\n\13\nlocal grid_controller = require(\"brgc/grid_controller\")\13\n\13\nfunction start()\13\n\9if grid_controller.isRunning() then\13\n\9\9io.stderr:write(\"Big Reactors Grid Control - Grid Controller service already running.\")\13\n\9else\13\n\9\9grid_controller.discoverStorage()\13\n\9\9grid_controller.start()\13\n\9end\13\nend\13\n\13\nfunction stop()\13\n\9if not grid_controller.isRunning() then\13\n\9\9io.stderr:write(\"Big Reactors Grid Control - Grid Controller service not running.\")\13\n\9else\13\n\9\9grid_controller.stop()\13\n\9end\13\nend\13\n\13\nfunction restart()\13\n\9if grid_controller.isRunning() then\13\n\9\9grid_controller.stop()\13\n\9end\13\n\9grid_controller.start()\13\nend\13\n\13\nfunction status()\13\n\9if grid_controller.isRunning() then\13\n\9\9io.write(\"Big Reactors Grid Control - Grid Controller is running.\")\13\n\9else\13\n\9\9io.write(\"Big Reactors Grid Control - Grid Controller is not running.\")\13\n\9end\13\nend",["/usr/lib/brgc/reactor_ctrl.lua"]="local computer = require(\"computer\")\nlocal component = require(\"component\")\nlocal event = require(\"event\")\nlocal config = require(\"brgc/config\")\nlocal reactorState = require(\"brgc/reactor_state\")\nlocal reactorFactory = require(\"brgc/reactor_factory\")\n\nlocal reactor_api = {\n\9mReactors = {},\n\9mDebug = false,\n\9mTimerId = nil,\n\9mSteamMax = 0,\n\9mSteamProductionTarget = 0\n}\n\nfunction reactor_api.reset()\n\9reactor_api.mReactors = {}\n\9reactor_api.mSteamMax = 0\nend\n\nfunction reactor_api.discover()\n\9local br_components = component.list(\"br_reactor\")\n\9config.load()\n\n\9for address, _ in pairs(br_components) do\n\9\9reactor_api.add(address)\n\9end\nend\n\nfunction reactor_api.add(address)\n\9checkArg(1, address, \"string\")\n\n\9if reactor_api.mReactors[address] == nil then\n\9\9local reactor = reactorFactory(address)\n\n\9\9if reactor ~= nil then\n\9\9\9if not reactor:isDisabled() then\n\9\9\9\9reactor:setState(reactorState.ONLINE)\n\9\9\9\9if reactor:isActivelyCooled() and reactor:isCalibrated() then\n\9\9\9\9\9reactor_api.mSteamMax = reactor_api.mSteamMax + reactor:getOutputGenerationRateMax()\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9reactor_api.mReactors[address] = reactor\n\n\9\9\9if reactor:isActivelyCooled() then\n\9\9\9\9computer.pushSignal(\"brgc_reactor_added\", address, \"active\")\n\9\9\9\9reactor_api.print(\"Connected with active reactor \" .. address)\n\9\9\9else\n\9\9\9\9computer.pushSignal(\"brgc_reactor_added\", address, \"passive\")\n\9\9\9\9reactor_api.print(\"Connected with passive reactor \" .. address)\n\9\9\9end\n\9\9end\n\9end\nend\n\nfunction reactor_api.remove(address)\n\9checkArg(1, address, \"string\")\n\n\9if reactor_api.mReactors[address] ~= nil then\n\9\9if reactor_api.mReactors[address]:isActivelyCooled() then\n\9\9\9reactor_api.mSteamMax = reactor_api.mSteamMax - reactor_api.mReactors[address]:getOutputGenerationRateMax()\n\9\9end\n\9\9reactor_api.mReactors[address] = nil\n\9\9computer.pushSignal(\"brgc_reactor_removed\", address)\n\9end\nend\n\nfunction reactor_api.reload()\n\9local reactors = { }\n\9config.load()\n\n\9for address, _ in pairs(reactor_api.mReactors) do\n\9\9table.insert(reactors, address)\n\9end\n\n\9for _, address in pairs(reactors) do\n\9\9reactor_api.remove(address)\n\9\9reactor_api.add(address)\n\9end\nend\n\nfunction reactor_api.setSteamProductionTarget(target)\n\9reactor_api.mSteamProductionTarget = math.max(0, target)\nend\n\nfunction reactor_api.getSteamProductionTarget()\n\9return reactor_api.mSteamProductionTarget\nend\n\nfunction reactor_api.runOnce()\n\9local maxsteam = 0\n\9for _, reactor in pairs(reactor_api.mReactors) do\n\9\9if reactor:isActivelyCooled() and reactor:isCalibrated() then\n\9\9\9if reactor_api.mSteamProductionTarget > 0 and reactor_api.mSteamMax > 0 then\n\9\9\9\9reactor:setSteamProductionTarget(reactor:getOutputGenerationRateMax() * reactor_api.mSteamProductionTarget / reactor_api.mSteamMax)\n\9\9\9else\n\9\9\9\9reactor:setSteamProductionTarget(0)\n\9\9\9end\n\9\9end\n\9\9reactor:runStateMachine()\n\9\9if reactor:isActivelyCooled() and reactor:isCalibrated() and not reactor:isDisabled() then\n\9\9\9maxsteam = maxsteam + reactor:getOutputGenerationRateMax()\n\9\9end\n\9end\n\9reactor_api.mSteamMax = maxsteam\nend\n\nfunction reactor_api.shutdown()\n\9reactor_api.setAsync(false)\n\9for _, reactor in pairs(reactor_api.mReactors) do\n\9\9reactor:setState(reactorState.OFFLINE)\n\9end\n\9reactor_api.reset()\nend\n\nfunction reactor_api.start()\n\9if reactor_api.mTimerId ~= nil then\n\9\9return false\n\9else\n\9\9event.listen(\"component_added\", reactor_api.asyncComponentAddedHandler)\n\9\9event.listen(\"component_removed\", reactor_api.asyncComponentRemovedHandler)\n\9\9reactor_api.mTimerId = event.timer(0.5, reactor_api.asyncTimerHandler, math.huge)\n\9\9return true\n\9end\nend\n\nfunction reactor_api.stop()\n\9if reactor_api.mTimerId == nil then\n\9\9return false\n\9else\n\9\9event.ignore(\"component_added\", reactor_api.asyncComponentAddedHandler)\n\9\9event.ignore(\"component_removed\", reactor_api.asyncComponentRemovedHandler)\n\9\9event.cancel(reactor_api.mTimerId)\n\9\9reactor_api.mTimerId = nil\n\9\9return true\n\9end\nend\n\nfunction reactor_api.isRunning()\n\9return reactor_api.mTimerId ~= nil\nend\n\nfunction reactor_api.toggleDebug()\n\9reactor_api.mDebug = not reactor_api.mDebug\nend\n\nfunction reactor_api.print(...)\n\9if reactor_api.mDebug then\n\9\9print(...)\n\9end\nend\n\n-- Async handlers\n\nfunction reactor_api.asyncComponentAddedHandler(_, address, typeID)\n\9if typeID == \"br_reactor\" then\n\9\9reactor_api.add(address)\n\9end\nend\n\nfunction reactor_api.asyncComponentRemovedHandler(_, address, typeID)\n\9if typeID == \"br_reactor\" then\n\9\9reactor_api.remove(address)\n\9end\nend\n\nfunction reactor_api.asyncTimerHandler()\n\9xpcall(reactor_api.runOnce, function(...) io.stderr:write(debug.traceback(...) .. \"\\n\") end)\nend\n\nreturn reactor_api",["/usr/lib/brgc/regulation_state.lua"]="local regulationState = {\13\n\9NONE = \"none\",\13\n\9AUTO = \"auto\",\13\n\9PWM = \"pwm\",\13\n\9LOAD = \"load\",\13\n\9GRID = \"grid\"\13\n}\13\n\13\nfunction regulationState.toString(state)\13\n\9if\9\9state == regulationState.NONE then\9return \"NONE\"\13\n\9elseif\9state == regulationState.AUTO then\9return \"AUTO\"\13\n\9elseif\9state == regulationState.PWM then\9return \"PWM\"\13\n\9elseif\9state == regulationState.LOAD then\9return \"LOAD\"\13\n\9elseif\9state == regulationState.GRID then\9return \"GRID\"\13\n\9else\9\9\9\9\9\9\9\9\9\9return \"UNKNOWN\"\13\n\9end\13\nend\13\n\13\nreturn regulationState",["/usr/lib/brgc/turbine_state.lua"]="local turbineState = {\13\n\9ERROR\9\9\9= -2,\13\n\9OFFLINE\9\9\9= -1,\13\n\9STARTING\9\9= 0,\13\n\9CALIBRATING\9\9= 1,\13\n\9KICKOFF\9\9\9= 2,\13\n\9SPINUP\9\9\9= 3,\13\n\9SPINUP_SLOW\9\9= 4,\13\n\9SPINDOWN\9\9= 5,\13\n\9SPINDOWN_FAST\9= 6,\13\n\9STABLE\9\9\9= 7,\13\n\9SUSPENDED\9\9= 8\13\n}\13\n\13\nfunction turbineState.toString(state)\13\n\9if\9\9state == turbineState.ERROR then\9\9\9return \"ERROR\"\13\n\9elseif\9state == turbineState.OFFLINE then\9\9\9return \"OFFLINE\"\13\n\9elseif\9state == turbineState.STARTING then\9\9\9return \"STARTING\"\13\n\9elseif\9state == turbineState.CALIBRATING then\9\9return \"CALIBRATING\"\13\n\9elseif\9state == turbineState.KICKOFF then\9\9\9return \"KICKOFF\"\13\n\9elseif\9state == turbineState.SPINUP then\9\9\9return \"SPINUP\"\13\n\9elseif\9state == turbineState.SPINUP_SLOW then\9\9return \"SLOW SPINUP\"\13\n\9elseif\9state == turbineState.SPINDOWN then\9\9\9return \"SPINDOWN\"\13\n\9elseif\9state == turbineState.SPINDOWN_FAST then\9return \"FAST SPINDOWN\"\13\n\9elseif\9state == turbineState.STABLE then\9\9\9return \"STABLE\"\13\n\9elseif\9state == turbineState.SUSPENDED then\9\9return \"SUSPENDED\"\13\n\9else\9\9\9\9\9\9\9\9\9\9\9\9return \"UNKNOWN\"\13\n\9end\13\nend\13\n\13\n\13\nreturn turbineState;",["/etc/rc.d/brgc_reactor.lua"]="--[[\13\nInit script for Big Reactors Grid Control - Reactor Controller for OpenComputers by XyFreak\13\nWebsite: http://tenyx.de/brgc/\13\n--]]\13\n\13\nlocal reactor_ctrl = require(\"brgc/reactor_ctrl\")\13\n\13\nfunction start()\13\n\9if reactor_ctrl.isRunning() then\13\n\9\9io.stderr:write(\"Big Reactors Grid Control - Reactor Controller service already running.\")\13\n\9else\13\n\9\9reactor_ctrl.discover()\13\n\9\9reactor_ctrl.start()\13\n\9end\13\nend\13\n\13\nfunction stop()\13\n\9if not reactor_ctrl.isRunning() then\13\n\9\9io.stderr:write(\"Big Reactors Grid Control - Reactor Controller service not running.\")\13\n\9else\13\n\9\9reactor_ctrl.stop()\13\n\9end\13\nend\13\n\13\nfunction restart()\13\n\9reactor_ctrl.reset()\13\n\9reactor_ctrl.discover()\13\n\9if not reactor_ctrl.isRunning() then\13\n\9\9reactor_ctrl.start()\13\n\9end\13\nend\13\n\13\nfunction status()\13\n\9if reactor_ctrl.isRunning() then\13\n\9\9io.write(\"Big Reactors Grid Control - Reactor Controller is running.\")\13\n\9else\13\n\9\9io.write(\"Big Reactors Grid Control - Reactor Controller is not running.\")\13\n\9end\13\nend",["/usr/lib/brgc/reactor_passive.lua"]="local oop = require(\"oop\")\nlocal promise = require(\"promise\")\nlocal config_api = require(\"brgc/config\")\nlocal reactorState = require(\"brgc/reactor_state\")\nlocal regulationState = require(\"brgc/regulation_state\")\nlocal reactor_base = require(\"brgc/reactor_base\")\nlocal polynomial_iterpolator = require(\"polynomial_iterpolator\")\n\nlocal gEnergyStoredMax = 10000000\n\nlocal reactor_passive = {\n\9mEnergyStoredTarget = gEnergyStoredMax/2\n}\n\noop.inherit(reactor_passive, reactor_base)\n\nfunction reactor_passive:construct(address, config)\n\9reactor_base.construct(self, address, config)\nend\n\nfunction reactor_passive:getOutputStats()\n\9if self.mComponent.getEnergyStats then\n\9\9local stats = self.mComponent.getEnergyStats()\n\9\9return {\n\9\9\9outputStored = stats.energyStored,\n\9\9\9outputCapacity = stats.energyCapacity,\n\9\9\9outputProducedLastTick = stats.energyProducedLastTick\n\9\9}\n\9else\n\9\9return {\n\9\9\9outputStored = self.mComponent.getEnergyStored(),\n\9\9\9outputCapacity = gEnergyStoredMax,\n\9\9\9outputProducedLastTick = self.mComponent.getEnergyProducedLastTick()\n\9\9}\n\9end\nend\n\nfunction reactor_passive:regulate()\n\9local grid_controller = _G.package.loaded[\"brgc/grid_controller\"]\n\9local behaviour = self:getRegulationBehaviour()\n\9if behaviour == regulationState.AUTO or ( behaviour == regulationState.GRID and (not grid_controller or not grid_controller.isRunning()) ) then\n\9\9local energyStored = self:getOutputStored()\n\9\9local energyLoad = self:getOutputExtractionRate()\n\n\9\9if self:getOptimalOutputGenerationRate() >= energyLoad and energyStored >= 2 * self:getOutputGenerationRate() then\n\9\9\9if self.mRegulationState == regulationState.LOAD then\n\9\9\9\9self:setOutput(self:getOutputOpt(), 0)\n\9\9\9end\n\9\9\9self.mRegulationState = regulationState.PWM\n\9\9elseif energyStored < self.mEnergyStoredTarget or energyLoad >= self:getOutputGenerationRateMax() then\n\9\9\9self.mRegulationState = regulationState.LOAD\n\9\9end\n\9elseif behaviour == regulationState.LOAD or behaviour == regulationState.PWM then\n\9\9if behaviour ~= self.mRegulationState and behaviour == regulationState.PWM then\n\9\9\9self:setOutput(self:getOutputOpt(), 0)\n\9\9end\n\9\9self.mRegulationState = behaviour\n\9elseif behaviour == regulationState.GRID then\n\9\9self.mRegulationState = regulationState.GRID\n\9end\n\n\9if self.mRegulationState == regulationState.PWM then\n\9\9self:regulatePWM()\n\9elseif self.mRegulationState == regulationState.LOAD then\n\9\9self:regulatePD()\n\9end\nend\n\nfunction reactor_passive:regulatePWM()\n\9local pEnergyStored = self:getOutputStored() / self:getOutputStoredMax()\n\n\9if pEnergyStored >= self.mReactorConfig.PWMLevelOffline then\n\9\9self:setOutput(0, 0)\n\9elseif pEnergyStored <= self.mReactorConfig.PWMLevelOnline then\n\9\9self:setOutput(self:getOutputOpt(), 0)\n\9end\nend\n\nfunction reactor_passive:regulatePD()\n\9local energyStored = self:getOutputStored()\n\9local energyStoredRate = self:getOutputStoredRate()\n\9local energyTargetDelta = self.mEnergyStoredTarget - energyStored\n\9local targetEnergyProduction\n\n\9local pEnergyStoredDelta = 0\n\9local pEnergyProductionDelta = 0\n\n\9if energyStored < 1 and energyStoredRate < 1 then\n\9\9targetEnergyProduction = self:getOutputGenerationRateMax()\n\9elseif energyStored >= self:getOutputStoredMax() - self:getOutputGenerationRate() and energyStoredRate >= 0 then\n\9\9targetEnergyProduction = 0\n\9else\n\9\9targetEnergyProduction = self:getOutputExtractionRate()\n\9\9pEnergyStoredDelta = energyTargetDelta / self:getOutputStoredMax()\n\9\9pEnergyProductionDelta = 0-energyStoredRate / self:getOutputGenerationRateMax()\n\9end\n\n\9local pTargetEnergyProduction = targetEnergyProduction / self:getOutputGenerationRateMax()\n\n\9self:regulatePD2(pTargetEnergyProduction, pEnergyStoredDelta, pEnergyProductionDelta)\nend\n\nfunction reactor_passive:regulatePD2(pTargetEnergyProduction, pEnergyStoredDelta, pEnergyProductionDelta)\n\9local energyOffset = pEnergyStoredDelta*1.25 + pEnergyProductionDelta\n\n\9self:setOutput( self:translateFromLinearOutput(pTargetEnergyProduction), energyOffset )\nend\n\nfunction reactor_passive.isGood()\n\9return true\nend\n\nfunction reactor_passive:finalizeCalibration()\n\9if #self.mCalibrationData < 6 or self.mReactorConfig.rodLevelMin >= 100 then\n\9\9self:setState(reactorState.ERROR)\n\9\9return\n\9end\n\n\9local rft_samples = {}\n\9local rft_reverse_samples = {}\n\9local efficiency_samples = {}\n\n\9for _, data in pairs(self.mCalibrationData) do\n\9\9table.insert(rft_samples, {\n\9\9\9data.load,\n\9\9\9data.value\n\9\9})\n\9\9table.insert(rft_reverse_samples, {\n\9\9\9data.value,\n\9\9\9data.load\n\9\9})\n\9\9table.insert(efficiency_samples, {\n\9\9\9data.load,\n\9\9\9data.efficiency\n\9\9})\n\9end\n\n\9self:setState(reactorState.OFFLINE)\n\9promise(function()\n\9\9local poly_output = polynomial_iterpolator.interpolate(rft_samples, 3)\n\n\9\9return poly_output\n\9end):after(function(poly_output)\n\9\9local poly_reverse_output = polynomial_iterpolator.interpolate(rft_reverse_samples, 5)\n\n\9\9return poly_output, poly_reverse_output\n\9end):after(function(poly_output, poly_reverse_output)\n\9\9local poly_efficiency = polynomial_iterpolator.interpolate(efficiency_samples, 6)\n\n\9\9return poly_output, poly_reverse_output, poly_efficiency\n\9end):after(function(reactor, poly_output, poly_reverse_output, poly_efficiency)\n\9\9reactor.mReactorConfig.outputPoly = poly_output\n\9\9reactor.mReactorConfig.outputReversePoly = poly_reverse_output\n\9\9reactor.mReactorConfig.outputOpt = math.max(0.01, math.min(1, poly_efficiency:converge(0, 10)))\n\9\9reactor:recalculateOpts()\n\9end, self):catch(function(reactor)\n\9\9if reactor:isConnected() then\n\9\9\9reactor:setState(reactorState.ERROR)\n\9\9end\n\9end, self):finally(function(reactor)\n\9\9reactor.mCalibrationData = nil\n\9\9reactor.mCalibrationStep = nil\n\9\9reactor.mCalibrationValueLast = nil\n\n\9\9if reactor:getState() ~= reactorState.ERROR then\n\9\9\9config_api.setReactor(reactor:getAddress(), reactor.mReactorConfig)\n\n\9\9\9if reactor:isConnected() then\n\9\9\9\9reactor:setOutput(0, 0)\n\9\9\9\9reactor:setState(reactorState.ONLINE)\n\9\9\9end\n\9\9end\n\9end, self)\nend\n\nreturn reactor_passive\n",["/usr/lib/brgc/energy_storage_component.lua"]="local component = require(\"component\")\13\nlocal computer = require(\"computer\")\13\nlocal oop = require(\"oop\")\13\n\13\nlocal energy_storage_component = {\13\n\9mAddress = nil,\13\n\9mComponent = nil,\13\n\9mEnergyTransformFactor = 1,\13\n\9mEnergyStored = 0,\13\n\9mEnergyStoredMax = 0,\13\n\9mEnergyStoredLast = 0,\13\n\9mLastUpdate = 0,\13\n\9mCompatibleComponents = {\13\n\9\9[\"capacitor_bank\"] = 1,\13\n\9\9[\"draconic_rf_storage\"] = 1,\13\n\9\9[\"rftools_powercell\"] = 1,\13\n\9\9[\"energy_device\"] = 1,\13\n\9\9[\"induction_matrix\"] = 0.4\13\n\9}\13\n}\13\noop.make(energy_storage_component)\13\n\13\nfunction energy_storage_component:construct(address)\13\n\9checkArg(1, address, \"string\")\13\n\13\n\9self.mAddress = address\13\n\9self.mComponent = component.proxy(address)\13\n\13\n\9if self.mComponent then\13\n\9\9self.mEnergyTransformFactor = energy_storage_component.mCompatibleComponents[self.mComponent.type] or 1\13\n\9end\13\n\13\n\9if self.mComponent and self.mComponent.getEnergy then\13\n\9\9self.mComponent.getEnergyStored = self.mComponent.getEnergy\13\n\9end\13\n\9if self.mComponent and self.mComponent.getMaxEnergy then\13\n\9\9self.mComponent.getMaxEnergyStored = self.mComponent.getMaxEnergy\13\n\9end\13\n\13\n\9if self.mComponent and self.mComponent.getEnergyStored and self.mComponent.getMaxEnergyStored then\13\n\9\9-- The component supports storing energy\13\n\9else\13\n\9\9self.mComponent = nil\13\n\9end\13\nend\13\n\13\nfunction energy_storage_component:isGood()\13\n\9return self.mComponent ~= nil\13\nend\13\n\13\nfunction energy_storage_component:getEnergyStored()\13\n\9return self.mEnergyStored\13\nend\13\n\13\nfunction energy_storage_component:getEnergyStoredLast()\13\n\9return self.mEnergyStoredLast\13\nend\13\n\13\nfunction energy_storage_component:getMaxEnergyStored()\13\n\9return self.mEnergyStoredMax\13\nend\13\n\13\nfunction energy_storage_component:update()\13\n\9local now = computer.uptime() * 20\13\n\9if now == self.mLastUpdate then\13\n\9\9return\13\n\9end\13\n\13\n\9self.mEnergyStoredLast = self.mEnergyStored\13\n\9self.mEnergyStored = self.mComponent.getEnergyStored() * self.mEnergyTransformFactor\13\n\9self.mEnergyStoredMax = self.mComponent.getMaxEnergyStored() * self.mEnergyTransformFactor\13\n\13\n\9self.mLastUpdate = now\13\nend\13\n\13\nfunction energy_storage_component.isCompatible(componentName)\13\n\9checkArg(1, componentName, \"string\")\13\n\13\n\9return not not energy_storage_component.mCompatibleComponents[componentName]\13\nend\13\n\13\nfunction energy_storage_component.isCompatibleAddress(componentAddress)\13\n\9checkArg(1, componentAddress, \"string\")\13\n\13\n\9local result1, result2 =  pcall(function()\13\n\9\9return energy_storage_component(componentAddress):isGood()\13\n\9end)\13\n\13\n\9return result1 and result2\13\nend\13\n\13\nreturn energy_storage_component\13\n"},name="br_grid_control",links={},version="4.33",depends={"oop","polynomial","promise","stringutils"}}