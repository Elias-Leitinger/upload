{checksums={["/usr/bin/brgc_gui.lua"]="Qi´3Dí¹ÛÁ1/+,{æÈ6‰§u³Ó‚A›Y®ì)fæi"},files={["/usr/lib/brgc/gui/generic_info_small.lua"]="local oop = require(\"oop\")\13\nlocal frame_base = require(\"libGUI/frame\")\13\nlocal colors = require(\"libGUI/colors\")\13\n\13\n\13\nlocal generic_info_small = {\13\n\9mBar = nil,\13\n\9mMessage = nil,\13\n\9mOutputString = nil,\13\n\9mOutputStringLenMax = 11,\13\n\9mDisplayName = nil,\13\n\9mDisplayNameLenMax = 3,\13\n\9mHasChanged = true\13\n}\13\noop.inherit(generic_info_small, frame_base)\13\n\13\nfunction generic_info_small:construct()\13\n\9frame_base.construct(self)\13\nend\13\n\13\nfunction generic_info_small.updateInfo()\13\nend\13\n\13\nfunction generic_info_small:onDraw(allowPartial)\13\n\9self:updateInfo()\13\n\9frame_base.onDraw(self, allowPartial and not self.mHasChanged)\13\n\13\n\9if not allowPartial or self.mHasChanged then\13\n\9\9local height_center = math.floor(self:getHeight()/2+0.5)\13\n\13\n\9\9self:setForeground(colors.white);\13\n\9\9self:set(1, height_center, self.mDisplayName or string.rep(\"-\", self.mDisplayNameLenMax))\13\n\13\n\9\9if self.mOutputString ~= nil then\13\n\9\9\9local ostr = string.rep(\" \", 1 + self.mOutputStringLenMax - string.len(self.mOutputString)) .. string.sub(self.mOutputString, 1, self.mOutputStringLenMax)\13\n\9\9\9self:set(self:getWidth()-string.len(ostr)+1, height_center, ostr)\13\n\9\9end\13\n\13\n\9\9if self.mMessage then\13\n\9\9\9local messageSpace = math.max(0, self:getWidth() - self.mDisplayNameLenMax - self.mOutputStringLenMax - 2)\13\n\9\9\9if messageSpace > 0 then\13\n\9\9\9\9local message = string.sub(self.mMessage, 1, messageSpace)\13\n\9\9\9\9local x = self.mDisplayNameLenMax + math.floor((messageSpace - string.len(message))/2+0.5) + 1\13\n\9\9\9\9self:setForeground(colors.red)\13\n\9\9\9\9self:setBackground(colors.black)\13\n\9\9\9\9self:set(x, height_center, self.mMessage)\13\n\9\9\9end\13\n\9\9end\13\n\9\9self.mHasChanged = false;\13\n\9end\13\nend\13\n\13\nfunction generic_info_small:onResize()\13\n\9frame_base.onResize(self)\13\n\9local width = self:getWidth()\13\n\13\n\9if self.mBar ~= nil then\13\n\9\9if width > self.mDisplayNameLenMax + self.mOutputStringLenMax + 2 then\13\n\9\9\9self:addChild(self.mBar)\13\n\9\9\9self.mBar:setRegion(self.mDisplayNameLenMax + 2, 1, width - self.mDisplayNameLenMax - self.mOutputStringLenMax - 2, self:getHeight())\13\n\9\9else\13\n\9\9\9self:removeChild(self.mBar)\13\n\9\9end\13\n\9end\13\nend\13\n\13\nreturn generic_info_small\13\n",["/usr/lib/brgc/gui/controller_info_big.lua"]="local oop = require(\"oop\")\13\nlocal stringutils = require(\"stringutils\")\13\nlocal libGUI = require(\"libGUI\")\13\nlocal colors = require(\"libGUI/colors\")\13\nlocal frame_base = require(\"libGUI/frame\")\13\nlocal reactorState = require(\"brgc/reactor_state\")\13\nlocal regulationState = require(\"brgc/regulation_state\")\13\nlocal reactor_load_bar = require(\"brgc/gui/reactor_load_bar\")\13\nlocal grid_controller = require(\"brgc/grid_controller\")\13\n\13\nlocal controller_info_big = {\13\n\9mReactorLoadBarLabel = nil,\13\n\9mReactorLoadBar = nil,\13\n\9mReactorLoadText = nil,\13\n\13\n\9mTurbineLoadBarLabel = nil,\13\n\9mTurbineLoadBar = nil,\13\n\9mTurbineLoadText = nil,\13\n\13\n\9mTotalLoadBarLabel = nil,\13\n\9mTotalLoadBar = nil,\13\n\9mTotalLoadText = nil,\13\n\13\n\9mInfoList = nil,\13\n\13\n\9mModeLabel = nil,\13\n\9mEnergyStoredLabel = nil,\13\n\9mEnergyProductionLabel = nil,\13\n\9mEnergyDemandLabel = nil,\13\n\13\n\9mStorageBar = nil,\13\n\9mModeButtonGroup = nil\13\n}\13\noop.inherit(controller_info_big, frame_base)\13\n\13\nfunction controller_info_big:construct()\13\n\9frame_base.construct(self)\13\n\13\n\9self.mReactorLoadBarLabel = libGUI.newFrame(\"label\", \"Reactors\", \"right\")\13\n\9self.mReactorLoadBar = reactor_load_bar()\13\n\9self.mReactorLoadText = libGUI.newFrame(\"label\", nil, \"left\")\13\n\13\n\9self.mTurbineLoadBarLabel = libGUI.newFrame(\"label\", \"Turbines\", \"right\")\13\n\9self.mTurbineLoadBar = libGUI.newFrame(\"bar\")\13\n\9self.mTurbineLoadBar:setBorderWidth(0)\13\n\9self.mTurbineLoadText = libGUI.newFrame(\"label\", nil, \"left\")\13\n\13\n\9self.mStorageBar = libGUI.newFrame(\"bar\")\13\n\9self.mStorageBar:setBorderWidth(2)\13\n\9self.mStorageBar:setBarPalette({{math.huge, colors.red}})\13\n\13\n\9self.mTotalLoadBarLabel = libGUI.newFrame(\"label\", \"Total\", \"right\")\13\n\9self.mTotalLoadBar = reactor_load_bar()\13\n\9self.mTotalLoadText = libGUI.newFrame(\"label\", nil, \"left\")\13\n\13\n\9self.mModeLabel = libGUI.newFrame(\"label\", nil, \"right\")\13\n\9self.mEnergyStoredLabel = libGUI.newFrame(\"label\", nil, \"right\")\13\n\9self.mEnergyProductionLabel = libGUI.newFrame(\"label\", nil, \"right\")\13\n\9self.mEnergyDemandLabel = libGUI.newFrame(\"label\", nil, \"right\")\13\n\13\n\9local infoListFrame = libGUI.newFrame(\"list\")\13\n\9infoListFrame:addChild(libGUI.newFrame(\"label\", \"Mode\", \"left\"))\13\n\9infoListFrame:addChild(self.mModeLabel)\13\n\9infoListFrame:addChild(libGUI.newFrame(\"label\", \"Energy Stored / Energy Max\"))\13\n\9infoListFrame:addChild(self.mEnergyStoredLabel)\13\n\9infoListFrame:addChild(libGUI.newFrame(\"label\", \"Energy Generation Rate (Optimal)\", \"left\"))\13\n\9infoListFrame:addChild(self.mEnergyProductionLabel)\13\n\9infoListFrame:addChild(libGUI.newFrame(\"label\", \"Energy Demand (Weighted)\", \"left\"))\13\n\9infoListFrame:addChild(self.mEnergyDemandLabel)\13\n\13\n\9self.mModeButtonGroup = libGUI.newFrame(\"horizontal_layout\", 1)\13\n\9local btnOnOff = libGUI.newFrame(\"toggle_button\", \"ON/OFF\", \"center\")\13\n\9local btnCharge = libGUI.newFrame(\"toggle_button\", \"Charge\", \"center\")\13\n\13\n\9function btnOnOff:onStateChange()\13\n\9\9if not self:getToggleState() then\13\n\9\9\9grid_controller.start()\13\n\9\9else\13\n\9\9\9grid_controller.stop()\13\n\9\9end\13\n\9end\13\n\9function btnOnOff:getToggleState()\13\n\9\9return grid_controller.isRunning()\13\n\9end\13\n\13\n\9function btnCharge:onStateChange()\13\n\9\9grid_controller.setChargeMode(not grid_controller.getChargeMode())\13\n\9end\13\n\9function btnCharge:getToggleState()\13\n\9\9return grid_controller.getChargeMode()\13\n\9end\13\n\13\n\9self.mModeButtonGroup:addChild(btnCharge)\13\n\9self.mModeButtonGroup:addChild(btnOnOff)\13\n\13\n\9self:addChild(self.mStorageBar)\13\n\9self:addChild(self.mReactorLoadBarLabel)\13\n\9self:addChild(self.mReactorLoadBar)\13\n\9self:addChild(self.mReactorLoadText)\13\n\9self:addChild(self.mTurbineLoadBarLabel)\13\n\9self:addChild(self.mTurbineLoadBar)\13\n\9self:addChild(self.mTurbineLoadText)\13\n\9self:addChild(self.mTotalLoadBarLabel)\13\n\9self:addChild(self.mTotalLoadBar)\13\n\9self:addChild(self.mTotalLoadText)\13\n\9self:addChild(infoListFrame)\13\n\9self:addChild(self.mModeButtonGroup)\13\n\13\n\9self.mInfoList = infoListFrame\13\nend\13\n\13\nfunction controller_info_big:updateInfo()\13\n\9if grid_controller.isRunning() then\13\n\13\n\9\9local energyStoredMax = grid_controller.getMaxEnergyStored()\13\n\9\9local energyStoredCurrent = grid_controller.getEnergyStored()\13\n\9\9local energyProducedReactors = grid_controller.getEnergyProductionRateReactors()\13\n\9\9local energyProducedTurbines = grid_controller.getEnergyProductionRateTurbines()\13\n\9\9local energyProducedTotal = grid_controller.getEnergyProductionRate()\13\n\9\9local energyProductionReactorsMax = grid_controller.getEnergyProductionRateReactorsMax()\13\n\9\9local energyProductionTurbinesMax = grid_controller.getEnergyProductionRateTurbinesMax()\13\n\9\9local energyProductionTotalMax = energyProductionReactorsMax + energyProductionTurbinesMax\13\n\9\9local energyProductionTotalOpt = grid_controller.getOptEnergyProduction()\13\n\9\9local energyProductionReactorOpt = energyProductionTotalOpt - energyProductionTurbinesMax\13\n\13\n\9\9self.mReactorLoadText:setText(stringutils.formatRFt(energyProducedReactors), false)\13\n\9\9self.mTurbineLoadText:setText(stringutils.formatRFt(energyProducedTurbines), false)\13\n\9\9self.mTotalLoadText:setText(stringutils.formatRFt(energyProducedTotal), false)\13\n\13\n\9\9if energyProductionReactorsMax <= 0 then\13\n\9\9\9self.mReactorLoadBar:setPercentage(0, false)\13\n\9\9else\13\n\9\9\9self.mReactorLoadBar:setPercentage(energyProducedReactors / energyProductionReactorsMax, false)\13\n\9\9end\13\n\9\9if self.mReactorLoadBar:getPercentageOptimal() ~= energyProductionReactorOpt / energyProductionReactorsMax then\13\n\9\9\9self.mReactorLoadBar:setPercentageOptimal(energyProductionReactorOpt / energyProductionReactorsMax)\13\n\9\9end\13\n\13\n\9\9if energyProductionTurbinesMax <= 0 then\13\n\9\9\9self.mTurbineLoadBar:setPercentage(0, false)\13\n\9\9else\13\n\9\9\9self.mTurbineLoadBar:setPercentage(energyProducedTurbines / energyProductionTurbinesMax, false)\13\n\9\9end\13\n\13\n\9\9if energyProductionTotalMax <= 0 then\13\n\9\9\9self.mTotalLoadBar:setPercentage(0, false)\13\n\9\9else\13\n\9\9\9self.mTotalLoadBar:setPercentage(energyProducedTotal / energyProductionTotalMax, false)\13\n\9\9end\13\n\9\9if self.mTotalLoadBar:getPercentageOptimal() ~= energyProductionTotalOpt / energyProductionTotalMax then\13\n\9\9\9self.mTotalLoadBar:setPercentageOptimal(energyProductionTotalOpt / energyProductionTotalMax)\13\n\9\9end\13\n\13\n\9\9if energyStoredMax <= 0 then\13\n\9\9\9self.mStorageBar:setPercentage(0, false)\13\n\9\9else\13\n\9\9\9self.mStorageBar:setPercentage(energyStoredCurrent / energyStoredMax, false)\13\n\9\9end\13\n\13\n\9\9if grid_controller.mState == 2 then\13\n\9\9\9self.mModeLabel:setText(\"HOLDING CHARGE\", false)\13\n\9\9elseif grid_controller.getChargeMode() then\13\n\9\9\9self.mModeLabel:setText(\"CHARGING\", false)\13\n\9\9elseif grid_controller.mState == 1 then\13\n\9\9\9self.mModeLabel:setText(\"INCREASING CHARGE\", false)\13\n\9\9elseif grid_controller.mState == 0 then\13\n\9\9\9self.mModeLabel:setText(\"DECREASING CHARGE\", false)\13\n\9\9else\13\n\9\9\9self.mModeLabel:setText(\"UNKNOWN\", false)\13\n\9\9end\13\n\13\n\9\9self.mEnergyStoredLabel:setText( \" \" .. stringutils.formatNumber(energyStoredCurrent, \"RF\", 0, 3) .. \" / \" .. stringutils.formatNumber(energyStoredMax, \"RF\", 0, 3) .. string.format(\" ( %5.02f%% )\", 100 * energyStoredCurrent / energyStoredMax), false)\13\n\9\9self.mEnergyProductionLabel:setText(stringutils.formatRFt(energyProducedTotal) .. \" (\" .. stringutils.formatRFt(energyProductionTotalOpt) .. \")\", false)\13\n\9\9self.mEnergyDemandLabel:setText(stringutils.formatRFt(grid_controller.getEnergyExtractionRate()) .. \" (\" .. stringutils.formatRFt(grid_controller.getEnergyExtractionRateWeighted()) .. \")\", false)\13\n\13\n\9else\13\n\9\9self.mModeLabel:setText(\"DISABLED\", false)\13\n\9\9self.mReactorLoadBar:setPercentage(0, false)\13\n\9\9self.mTurbineLoadBar:setPercentage(0, false)\13\n\9\9self.mTotalLoadBar:setPercentage(0, false)\13\n\9\9self.mStorageBar:setPercentage(0, false)\13\n\9\9self.mEnergyStoredLabel:setText(\"---\", false)\13\n\9\9self.mEnergyProductionLabel:setText(\"---\", false)\13\n\9\9self.mEnergyDemandLabel:setText(\"--- (---)\", false)\13\n\9end\13\nend\13\n\13\nfunction controller_info_big:onDraw(allowPartial)\13\n\9self:updateInfo()\13\n\9frame_base.onDraw(self, allowPartial)\13\nend\13\n\13\nfunction controller_info_big:onResize()\13\n\9frame_base.onResize(self)\13\n\9local width, height = self:getSize()\13\n\13\n\9self.mStorageBar:setRegion(2, 2, 8, height - 2)\13\n\13\n\9self.mReactorLoadBarLabel:setRegion(13, 2, 8, 1)\13\n\9self.mReactorLoadBar:setRegion(22, 2, width - 35, 1)\13\n\9self.mReactorLoadText:setRegion(width - 12, 2, 11, 1)\13\n\13\n\9self.mTurbineLoadBarLabel:setRegion(13, 3, 8, 1)\13\n\9self.mTurbineLoadBar:setRegion(22, 3, width - 35, 1)\13\n\9self.mTurbineLoadText:setRegion(width - 12, 3, 11, 1)\13\n\13\n\9self.mTotalLoadBarLabel:setRegion(13, 4, 8, 1)\13\n\9self.mTotalLoadBar:setRegion(22, 4, width - 35, 1)\13\n\9self.mTotalLoadText:setRegion(width - 12, 4, 11, 1)\13\n\13\n\9if height < 10 and self.mInfoList:getParent() ~= nil then\13\n\9\9self:removeChild(self.mInfoList)\13\n\9elseif height >= 10 and self.mInfoList:getParent() == nil then\13\n\9\9self:addChild(self.mInfoList)\13\n\9end\13\n\13\n\9if self.mInfoList:getParent() ~= nil then\13\n\9\9self.mInfoList:setRegion(13, 6, width - 13, math.min(#self.mInfoList.mChildren, height - 9))\13\n\9end\13\n\9self.mModeButtonGroup:setRegion(12, height - 3, width - 12, 3)\13\nend\13\n\13\nreturn controller_info_big\13\n",["/usr/bin/brgc_gui.lua"]="local event = require(\"event\")\13\nlocal libGUI = require(\"libGUI\")\13\nlocal reactor_ctrl = require(\"brgc/reactor_ctrl\")\13\nlocal turbine_ctrl = require(\"brgc/turbine_ctrl\")\13\n\13\nlocal reactor_info_small = require(\"brgc/gui/reactor_info_small\")\13\nlocal turbine_info_small = require(\"brgc/gui/turbine_info_small\")\13\n\13\nlocal reactor_info_big = require(\"brgc/gui/reactor_info_big\")\13\nlocal turbine_info_big = require(\"brgc/gui/turbine_info_big\")\13\n\13\nlocal controller_info_big = require(\"brgc/gui/controller_info_big\")\13\n\13\nlocal tabframe = libGUI.newFrame(\"tabframe\")\13\nlocal list_r = libGUI.newFrame(\"list\")\13\nlocal list_t = libGUI.newFrame(\"list\")\13\nlocal list_c = libGUI.newFrame(\"list\")\13\nlocal grid_view = controller_info_big()\13\n\13\n--\13\n\13\nlocal function update_list()\13\n\9local reactors = {}\13\n\9local turbines = {}\13\n\13\n\9for _, reactor in pairs(reactor_ctrl.mReactors or {}) do\13\n\9\9table.insert(reactors, reactor)\13\n\9end\13\n\9for _, turbine in pairs(turbine_ctrl.mTurbines or {}) do\13\n\9\9table.insert(turbines, turbine)\13\n\9end\13\n\13\n\9table.sort(reactors, function(a,b) return a:getAddress() < b:getAddress() end)\13\n\9table.sort(turbines, function(a,b) return a:getAddress() < b:getAddress() end)\13\n\13\n--\9if #list_r.mChildren ~= #reactors then\13\n\9\9while #list_r.mChildren > 0 do\13\n\9\9\9list_r:removeChild(list_r.mChildren[1])\13\n\9\9end\13\n\13\n\9\9for _, reactor in pairs(reactors) do\13\n\9\9\9local rframe = reactor_info_small(reactor)\13\n\9\9\9function rframe:onTouch() tabframe:setFrameActive(reactor_info_big(reactor)) end\13\n\9\9\9list_r:addChild(rframe)\13\n\9\9end\13\n--\9end\13\n\13\n--\9if #list_t.mChildren ~= #turbines then\13\n\9\9while #list_t.mChildren > 0 do\13\n\9\9\9list_t:removeChild(list_t.mChildren[1])\13\n\9\9end\13\n\13\n\9\9for _, turbine in pairs(turbines) do\13\n\9\9\9local tframe = turbine_info_small(turbine)\13\n\9\9\9function tframe:onTouch() tabframe:setFrameActive(turbine_info_big(turbine)) end\13\n\9\9\9list_t:addChild(tframe)\13\n\9\9end\13\n--\9end\13\n\13\n--\9if #list_c.mChildren ~= #reactors+#turbines then\13\n\9\9while #list_c.mChildren > 0 do\13\n\9\9\9list_c:removeChild(list_c.mChildren[1])\13\n\9\9end\13\n\13\n\9\9list_c:addChild(libGUI.newFrame(\"label\", \"Reactors\", \"center\"))\13\n\9\9for _, reactor in pairs(reactors) do\13\n\9\9\9local rframe = reactor_info_small(reactor)\13\n\9\9\9function rframe:onTouch() tabframe:setFrameActive(reactor_info_big(reactor)) end\13\n\9\9\9list_c:addChild(rframe)\13\n\9\9end\13\n\9\9list_c:addChild(libGUI.newFrame(\"label\", \"Turbines\", \"center\"))\13\n\9\9for _, turbine in pairs(turbines) do\13\n\9\9\9local tframe = turbine_info_small(turbine)\13\n\9\9\9function tframe:onTouch() tabframe:setFrameActive(turbine_info_big(turbine)) end\13\n\9\9\9list_c:addChild(tframe)\13\n\9\9end\13\n--\9end\13\n\13\n--\9tabframe:onDraw()\13\nend\13\n\13\nlocal function update_list_callback()\13\n\9xpcall(update_list, function(...)\13\n\9\9libGUI.exit()\13\n\9\9io.stderr:write(\"[BRGCGUI] \" .. debug.traceback( ... ) .. \"\\n\")\13\n\9end)\13\n\9tabframe:onDraw(false)\13\nend\13\n\13\n\13\nlocal function onTerminate()\13\n\9event.ignore(\"brgc_reactor_added\", update_list_callback)\13\n\9event.ignore(\"brgc_turbine_added\", update_list_callback)\13\n\9event.ignore(\"libGUI_terminate\", onTerminate)\13\nend\13\n\13\n--\13\n\13\nlibGUI.init()\13\nlibGUI.setRootFrame(tabframe)\13\nlibGUI.setOptimalResolutionByTier(0.5, 1)\13\n\13\nupdate_list()\13\n\13\ntabframe:addItem(\"Grid\", nil, grid_view)\13\ntabframe:addItem(\"Combined\", nil, list_c)\13\nif libGUI.getResolution() > 60 then\13\n\9tabframe:addItem(\"Reactors\", nil, list_r)\13\n\9tabframe:addItem(\"Turbines\", nil, list_t)\13\nend\13\ntabframe:addItem(\"Exit\", libGUI.exit, nil)\13\n\13\ntabframe:activateItem(\"Combined\")\13\n\13\nevent.listen(\"brgc_reactor_added\", update_list_callback)\13\nevent.listen(\"brgc_turbine_added\", update_list_callback)\13\nevent.listen(\"libGUI_terminate\", onTerminate)\13\n\13\nlibGUI.setRedrawInterval(1)\13\nlibGUI.runOrFork()",["/usr/lib/brgc/gui/turbine_info_small.lua"]="local oop = require(\"oop\")\13\nlocal stringutils = require(\"stringutils\")\13\nlocal turbineState = require(\"brgc/turbine_state\")\13\nlocal turbine_speed_bar = require(\"brgc/gui/turbine_speed_bar\")\13\nlocal generic_info_small = require(\"brgc/gui/generic_info_small\")\13\n\13\n\13\nlocal turbine_info_small = {\13\n\9mTurbine = nil\13\n}\13\noop.inherit(turbine_info_small, generic_info_small)\13\n\13\nfunction turbine_info_small:construct(turbine)\13\n\9generic_info_small.construct(self)\13\n\13\n\9self.mBar = turbine_speed_bar()\13\n\13\n\9self.mTurbine = turbine\13\nend\13\n\13\nfunction turbine_info_small:updateInfo()\13\n\9local message = nil\13\n\9local outputString\13\n\9if self.mTurbine:isConnected() then\13\n\9\9local state = self.mTurbine:getState()\13\n\9\9local RFt = self.mTurbine:getOutputGenerationRate()\13\n\9\9self.mDisplayName = self.mTurbine:getAddressShort()\13\n\9\9if RFt > 0 then\13\n\9\9\9outputString = stringutils.formatRFt(RFt, true)\13\n\9\9else\13\n\9\9\9outputString = string.format(\"%4d RPM\", math.floor(self.mTurbine:getRPM() + 0.5))\13\n\9\9end\13\n\13\n\9\9if self.mTurbine:getRPMOptimal() ~= nil and self.mBar:getPercentageOptimal() ~= self.mTurbine:getRPMOptimal() / 1850 then\13\n\9\9\9self.mBar:setPercentageOptimal(self.mTurbine:getRPMOptimal() / 1850)\13\n\9\9end\13\n\9\9self.mBar:setPercentage(self.mTurbine:getRPM() / 1850, false)\13\n\9\9-- Do not use turbineState.toString because we don't want certain strings to show up!\13\n\9\9if state == turbineState.ERROR then\13\n\9\9\9message = \"ERROR\"\13\n\9\9elseif state == turbineState.OFFLINE then\13\n\9\9\9message = \"OFFLINE\"\13\n\9\9elseif state == turbineState.CALIBRATING then\13\n\9\9\9message = \"CALIBRATING\"\13\n\9\9elseif state == turbineState.SUSPENDED then\13\n\9\9\9message = \"SUSPENDED\"\13\n\9\9elseif state == turbineState.KICKOFF then\13\n\9\9\9message = \"KICKOFF\"\13\n\9\9end\13\n\9else\13\n\9\9outputString = nil\13\n\9\9self.mBar:setPercentage(0, false)\13\n\9\9message = \"DISCONNECTED\"\13\n\9end\13\n\13\n\9self.mHasChanged = message ~= self.mMessage or outputString ~= self.mOutputString or self.mBar.mHasChanged\13\n\9self.mMessage = message\13\n\9self.mOutputString = outputString\13\nend\13\n\13\nreturn turbine_info_small\13\n",["/usr/lib/brgc/gui/turbine_info_big.lua"]="local oop = require(\"oop\")\13\nlocal stringutils = require(\"stringutils\")\13\nlocal libGUI = require(\"libGUI\")\13\nlocal colors = require(\"libGUI/colors\")\13\nlocal frame_base = require(\"libGUI/frame\")\13\nlocal turbineState = require(\"brgc/turbine_state\")\13\nlocal config = require(\"brgc/config\")\13\nlocal turbine_speed_bar = require(\"brgc/gui/turbine_speed_bar\")\13\n\13\n\13\nlocal turbine_info_big = {\13\n\9mTurbine = nil,\13\n\9mSpeedBar = nil,\13\n\9mStorageBar = nil,\13\n\13\n\9mInfoList = nil,\13\n\13\n\9mAddressLabel = nil,\13\n\9mAddressCaptionLabel = nil,\13\n\13\n\9mStateLabel = nil,\13\n\9mStateCaptionLabel = nil,\13\n\13\n\9mSpeedLabel = nil,\13\n\9mSpeedCaptionLabel = nil,\13\n\13\n\9mGenerationLabel = nil,\13\n\9mGenerationCaptionLabel = nil,\13\n\13\n\9mOutputLabel = nil,\13\n\9mOutputCaptionLabel = nil,\13\n\13\n\9mConsumptionLabel = nil,\13\n\9mConsumptionCaptionLabel = nil,\13\n\13\n\9mModeToggleButtonGroup = nil\13\n}\13\noop.inherit(turbine_info_big, frame_base)\13\n\13\nfunction turbine_info_big:construct(turbine)\13\n\9frame_base.construct(self)\13\n\13\n\9self.mSpeedBar = turbine_speed_bar()\13\n\9self.mSpeedBar:setBorderWidth(2)\13\n\9self.mStorageBar = libGUI.newFrame(\"bar\")\13\n\9self.mStorageBar:setBorderWidth(2)\13\n\9self.mStorageBar:setBarPalette({{math.huge, colors.red}})\13\n\13\n\9local infoListFrame = libGUI.newFrame(\"list\")\13\n\13\n\9self.mAddressLabel = libGUI.newFrame(\"label\", turbine:getAddress(), \"right\")\13\n\9self.mAddressCaptionLabel = libGUI.newFrame(\"label\", \"Turbine\")\13\n\13\n\9self.mStateLabel = libGUI.newFrame(\"label\", nil, \"right\")\13\n\9self.mStateCaptionLabel = libGUI.newFrame(\"label\", \"State\")\13\n\13\n\9self.mSpeedLabel = libGUI.newFrame(\"label\", nil, \"right\")\13\n\9self.mSpeedCaptionLabel = libGUI.newFrame(\"label\", \"Speed (Target)\")\13\n\13\n\9self.mGenerationLabel = libGUI.newFrame(\"label\", nil, \"right\")\13\n\9self.mGenerationCaptionLabel = libGUI.newFrame(\"label\", \"Current Generation\")\13\n\13\n\9self.mOutputLabel = libGUI.newFrame(\"label\", nil, \"right\")\13\n\9self.mOutputCaptionLabel = libGUI.newFrame(\"label\", \"Current Output\")\13\n\13\n\9self.mConsumptionLabel = libGUI.newFrame(\"label\", nil, \"right\")\13\n\9self.mConsumptionCaptionLabel = libGUI.newFrame(\"label\", \"Steam Consumption\")\13\n\13\n\9infoListFrame:addChild(self.mAddressCaptionLabel); infoListFrame:addChild(self.mAddressLabel)\13\n\9infoListFrame:addChild(self.mStateCaptionLabel); infoListFrame:addChild(self.mStateLabel)\13\n\9infoListFrame:addChild(self.mSpeedCaptionLabel); infoListFrame:addChild(self.mSpeedLabel)\13\n\9infoListFrame:addChild(self.mGenerationCaptionLabel); infoListFrame:addChild(self.mGenerationLabel)\13\n\9infoListFrame:addChild(self.mOutputCaptionLabel); infoListFrame:addChild(self.mOutputLabel)\13\n\9infoListFrame:addChild(self.mConsumptionCaptionLabel); infoListFrame:addChild(self.mConsumptionLabel)\13\n\13\n\9self.mModeToggleButtonGroup = libGUI.newFrame(\"horizontal_layout\", 1)\13\n\9local btnOnOff = libGUI.newFrame(\"toggle_button\", \"ON/OFF\", \"center\")\13\n\9local btnIndependent = libGUI.newFrame(\"toggle_button\", \"Independent\", \"center\")\13\n\13\n\9function btnOnOff:onStateChange()\13\n\9\9if not self:getToggleState() then\13\n\9\9\9turbine:setState(turbineState.STARTING)\13\n\9\9\9turbine:setDisabled(false)\13\n\9\9else\13\n\9\9\9turbine:setState(turbineState.OFFLINE)\13\n\9\9\9turbine:setDisabled(true)\13\n\9\9end\13\n\9end\13\n\9function btnOnOff:getToggleState()\13\n\9\9return turbine:getState() ~= turbineState.OFFLINE and turbine:getState() ~= turbineState.ERROR\13\n\9end\13\n\13\n\9function btnIndependent:onStateChange()\13\n\9\9turbine:setIndependent(not turbine:isIndependent())\13\n\9\9config:setTurbineAttribute(turbine:getAddress(), \"independent\", turbine:isIndependent())\13\n\9end\13\n\9function btnIndependent:getToggleState()\13\n\9\9return turbine:isIndependent()\13\n\9end\13\n\13\n\9self.mModeToggleButtonGroup:addChild(btnOnOff)\13\n\9self.mModeToggleButtonGroup:addChild(btnIndependent)\13\n\13\n\9self:addChild(self.mSpeedBar)\13\n\9self:addChild(self.mStorageBar)\13\n\9self:addChild(infoListFrame)\13\n\9self:addChild(self.mModeToggleButtonGroup)\13\n\13\n\9self.mTurbine = turbine\13\n\9self.mInfoList = infoListFrame\13\nend\13\n\13\nfunction turbine_info_big:updateInfo()\13\n\9if self.mTurbine:isConnected() then\13\n\9\9self.mGenerationLabel:setText(stringutils.formatRFt(self.mTurbine:getOutputGenerationRate()), false)\13\n\9\9self.mOutputLabel:setText(stringutils.formatRFt(self.mTurbine:getOutputExtractionRate()), false)\13\n\13\n\9\9self.mStorageBar:setPercentage(self.mTurbine:getOutputStored() / self.mTurbine:getOutputStoredMax(), false)\13\n\9\9if self.mTurbine:getRPMOptimal() ~= nil and self.mSpeedBar:getPercentageOptimal() ~= self.mTurbine:getRPMOptimal() / 1850 then\13\n\9\9\9self.mSpeedBar:setPercentageOptimal(self.mTurbine:getRPMOptimal() / 1850)\13\n\9\9end\13\n\9\9self.mSpeedBar:setPercentage(self.mTurbine:getRPM() / 1850, false)\13\n\13\n\9\9self.mStateLabel:setText(turbineState.toString(self.mTurbine:getState()), false)\13\n\9\9self.mSpeedLabel:setText(math.floor(self.mTurbine:getRPM() + 0.5) .. \" RPM (\" .. math.floor(self.mTurbine:getRPMTarget() or 0 + 0.5) .. \" RPM)\")\13\n\9\9self.mConsumptionLabel:setText(stringutils.formatBt(self.mTurbine:getSteamRate() / 1000, false))\13\n\9else\13\n\9\9self.mStateLabel:setForeground(colors.red)\13\n\9\9self.mStateLabel:setText(\"DISCONNECTED\", false)\13\n\9\9self.mSpeedBar:setPercentage(0, false)\13\n\9\9self.mStorageBar:setPercentage(0, false)\13\n\9\9self.mSpeedLabel:setText(\"N/A\", false)\13\n\9\9self.mGenerationLabel:setText(\"N/A\", false)\13\n\9\9self.mOutputLabel:setText(\"N/A\", false)\13\n\9\9self.mConsumptionLabel:setText(\"N/A\", false)\13\n\9end\13\nend\13\n\13\nfunction turbine_info_big:onDraw(allowPartial)\13\n\9self:updateInfo()\13\n\9frame_base.onDraw(self, allowPartial)\13\nend\13\n\13\nfunction turbine_info_big:onResize()\13\n\9frame_base.onResize(self)\13\n\13\n\9local width, height = self:getSize()\13\n\13\n\9self.mSpeedBar:setRegion(2, 2, 8, height - 2)\13\n\9self.mStorageBar:setRegion(12, 2, 8, height - 2)\13\n\9self.mInfoList:setRegion(24, 2, width - 25, #self.mInfoList.mChildren)\13\n\9self.mModeToggleButtonGroup:setRegion(24, height - 3, width - 24, 3)\13\nend\13\n\13\nreturn turbine_info_big\13\n",["/usr/lib/brgc/gui/reactor_load_bar.lua"]="local oop = require(\"oop\")\13\nlocal bar_base = require(\"libGUI/bar\")\13\nlocal colors = require(\"libGUI/colors\")\13\n\13\nlocal reactor_load_bar = {\13\n\9mPercentageOptimal = nil\13\n}\13\noop.inherit(reactor_load_bar, bar_base)\13\n\13\nfunction reactor_load_bar:construct()\13\n\9bar_base.construct(self)\13\n\13\n\9self:setBorderWidth(0)\13\n\9self:setBackground(colors.gray)\13\n\9self:setPercentageOptimal(self.mPercentageOptimal)\13\nend\13\n\13\nfunction reactor_load_bar:setPercentageOptimal(percentage)\13\n\9local newPalette\13\n\13\n\9if percentage == nil then\13\n\9\9newPalette = {\13\n\9\9\9{ math.huge, colors.green }\13\n\9\9}\13\n\9else\13\n\9\9newPalette = {\13\n\9\9\9{ percentage * 0.8, colors.blue },\13\n\9\9\9{ percentage * 0.9, colors.lightblue },\13\n\9\9\9{ percentage * 1.1, colors.green },\13\n\9\9\9{ percentage * 1.2, colors.purple },\13\n\9\9\9{ percentage * 1.3, colors.orange },\13\n\9\9\9{    math.huge    , colors.red }\13\n\9\9}\13\n\9end\13\n\13\n\9self.mPercentageOptimal = percentage\13\n\9self:setBarPalette(newPalette)\13\nend\13\n\13\nfunction reactor_load_bar:getPercentageOptimal()\13\n\9return self.mPercentageOptimal\13\nend\13\n\13\n\13\nreturn reactor_load_bar\13\n",["/usr/lib/brgc/gui/reactor_info_small.lua"]="local oop = require(\"oop\")\13\nlocal stringutils = require(\"stringutils\")\13\nlocal reactorState = require(\"brgc/reactor_state\")\13\nlocal reactor_load_bar = require(\"brgc/gui/reactor_load_bar\")\13\nlocal generic_info_small = require(\"brgc/gui/generic_info_small\")\13\n\13\n\13\nlocal reactor_info_small = {\13\n\9mReactor = nil\13\n}\13\noop.inherit(reactor_info_small, generic_info_small)\13\n\13\nfunction reactor_info_small:construct(reactor)\13\n\9generic_info_small.construct(self)\13\n\13\n\9self.mBar = reactor_load_bar()\13\n\13\n\9self.mReactor = reactor\13\nend\13\n\13\nfunction reactor_info_small:updateInfo()\13\n\9local message = nil\13\n\9local outputString\13\n\9if self.mReactor:isConnected() then\13\n\9\9local state = self.mReactor:getState()\13\n\9\9self.mDisplayName = self.mReactor:getAddressShort()\13\n\9\9if self.mReactor:isActivelyCooled() then\13\n\9\9\9outputString = stringutils.formatBt(self.mReactor:getOutputGenerationRate() / 1000)\13\n\9\9else\13\n\9\9\9outputString = stringutils.formatRFt(self.mReactor:getOutputGenerationRate())\13\n\9\9end\13\n\13\n\9\9if self.mBar:getPercentageOptimal() ~= self.mReactor:getOutputOpt() then\13\n\9\9\9self.mBar:setPercentageOptimal(self.mReactor:getOutputOpt())\13\n\9\9end\13\n\9\9self.mBar:setPercentage(self.mReactor:getOutput(), false)\13\n\9\9-- Do not use reactorState.toString because we don't want certain strings to show up!\13\n\9\9if state == reactorState.ERROR then\13\n\9\9\9message = \"ERROR\"\13\n\9\9elseif state == reactorState.OFFLINE then\13\n\9\9\9message = \"OFFLINE\"\13\n\9\9elseif state == reactorState.CALIBRATING then\13\n\9\9\9message = \"CALIBRATING\"\13\n\9\9elseif state == reactorState.OPTIMIZING then\13\n\9\9\9message = \"OPTIMIZING\"\13\n\9\9end\13\n\9else\13\n\9\9outputString = nil\13\n\9\9self.mBar:setPercentage(0, false)\13\n\9\9message = \"DISCONNECTED\"\13\n\9end\13\n\13\n\9self.mHasChanged = message ~= self.mMessage or outputString ~= self.mOutputString or self.mBar.mHasChanged\13\n\9self.mMessage = message\13\n\9self.mOutputString = outputString\13\nend\13\n\13\nreturn reactor_info_small\13\n",["/usr/lib/brgc/gui/turbine_speed_bar.lua"]="local oop = require(\"oop\")\13\nlocal bar_base = require(\"libGUI/bar\")\13\nlocal colors = require(\"libGUI/colors\")\13\n\13\nlocal turbine_speed_bar = {\13\n\9mPercentageOptimal = 1777/1850\13\n}\13\noop.inherit(turbine_speed_bar, bar_base)\13\n\13\nfunction turbine_speed_bar:construct()\13\n\9bar_base.construct(self)\13\n\13\n\9self:setBorderWidth(0)\13\n\9self:setBackground(colors.gray)\13\n\9self:setPercentageOptimal(self.mPercentageOptimal)\13\nend\13\n\13\nfunction turbine_speed_bar:setPercentageOptimal(percentage)\13\n\9local newPalette = {\13\n\9\9{  350 / 1850, colors.blue },\13\n\9\9{  750 / 1850, colors.lightblue },\13\n\9\9{ 1050 / 1850, colors.lime },\13\n\9\9{ 1600 / 1850, colors.cyan },\13\n\9\9{  percentage, colors.lime },\13\n\9\9{ 1800 / 1850, colors.green },\13\n\9\9{ 1850 / 1850, colors.yellow },\13\n\9\9{  math.huge , colors.red }\13\n\9}\13\n\13\n\9self.mPercentageOptimal = percentage\13\n\9self:setBarPalette(newPalette)\13\nend\13\n\13\nfunction turbine_speed_bar:getPercentageOptimal()\13\n\9return self.mPercentageOptimal\13\nend\13\n\13\nfunction turbine_speed_bar:getTranslatedPercentage(percentage)\13\n\9return percentage and (percentage * percentage) or self.mPercentage * self.mPercentage\13\nend\13\n\13\n\13\nreturn turbine_speed_bar\13\n",["/usr/lib/brgc/gui/reactor_info_big.lua"]="local oop = require(\"oop\")\13\nlocal stringutils = require(\"stringutils\")\13\nlocal libGUI = require(\"libGUI\")\13\nlocal colors = require(\"libGUI/colors\")\13\nlocal frame_base = require(\"libGUI/frame\")\13\nlocal reactorState = require(\"brgc/reactor_state\")\13\nlocal regulationState = require(\"brgc/regulation_state\")\13\nlocal reactor_load_bar = require(\"brgc/gui/reactor_load_bar\")\13\n\13\n\13\nlocal reactor_info_big = {\13\n\9mReactor = nil,\13\n\9mLoadBar = nil,\13\n\9mStorageBar = nil,\13\n\13\n\9mInfoList = nil,\13\n\13\n\9mAddressLabel = nil,\13\n\9mAddressCaptionLabel = nil,\13\n\13\n\9mStateLabel = nil,\13\n\9mStateCaptionLabel = nil,\13\n\13\n\9mModeLabel = nil,\13\n\9mModeCaptionLabel = nil,\13\n\13\n\9mHeatLabel = nil,\13\n\9mHeatCaptionLabel = nil,\13\n\13\n\9mGenerationLabel = nil,\13\n\9mGenerationCaptionLabel = nil,\13\n\13\n\9mOutputLabel = nil,\13\n\9mOutputCaptionLabel = nil,\13\n\13\n\9mConsumptionLabel = nil,\13\n\9mConsumptionCaptionLabel = nil,\13\n\13\n\9mModeToggleButtonGroup = nil,\13\n\9mModeToggleButtonGroup2 = nil,\13\n\9mDisableButton = nil,\13\n\9mModeGridButton = nil\13\n}\13\noop.inherit(reactor_info_big, frame_base)\13\n\13\nfunction reactor_info_big:construct(reactor)\13\n\9frame_base.construct(self)\13\n\13\n\9self.mLoadBar = reactor_load_bar()\13\n\9self.mLoadBar:setBorderWidth(2)\13\n\9self.mStorageBar = libGUI.newFrame(\"bar\")\13\n\9self.mStorageBar:setBorderWidth(2)\13\n\13\n\9local infoListFrame = libGUI.newFrame(\"list\")\13\n\13\n\9self.mAddressLabel = libGUI.newFrame(\"label\", reactor:getAddress(), \"right\")\13\n\9self.mAddressCaptionLabel = libGUI.newFrame(\"label\", \"Reactor\")\13\n\13\n\9self.mStateLabel = libGUI.newFrame(\"label\", nil, \"right\")\13\n\9self.mStateCaptionLabel = libGUI.newFrame(\"label\", \"State\")\13\n\13\n\9self.mModeLabel = libGUI.newFrame(\"label\", nil, \"right\")\13\n\9self.mModeCaptionLabel = libGUI.newFrame(\"label\", \"Mode\")\13\n\13\n\9self.mHeatLabel = libGUI.newFrame(\"label\", nil, \"right\")\13\n\9self.mHeatCaptionLabel = libGUI.newFrame(\"label\", \"Core Heat\")\13\n\13\n\9self.mGenerationLabel = libGUI.newFrame(\"label\", nil, \"right\")\13\n\9self.mGenerationCaptionLabel = libGUI.newFrame(\"label\", \"Current Generation\")\13\n\13\n\9self.mOutputLabel = libGUI.newFrame(\"label\", nil, \"right\")\13\n\9self.mOutputCaptionLabel = libGUI.newFrame(\"label\", \"Current Output\")\13\n\13\n\9self.mConsumptionLabel = libGUI.newFrame(\"label\", nil, \"right\")\13\n\9self.mConsumptionCaptionLabel = libGUI.newFrame(\"label\", \"Fuel Consumption (Level %)\")\13\n\13\n\9infoListFrame:addChild(self.mAddressCaptionLabel); infoListFrame:addChild(self.mAddressLabel)\13\n\9infoListFrame:addChild(self.mStateCaptionLabel); infoListFrame:addChild(self.mStateLabel)\13\n\9infoListFrame:addChild(self.mModeCaptionLabel); infoListFrame:addChild(self.mModeLabel)\13\n\9infoListFrame:addChild(self.mHeatCaptionLabel); infoListFrame:addChild(self.mHeatLabel)\13\n\9infoListFrame:addChild(self.mGenerationCaptionLabel); infoListFrame:addChild(self.mGenerationLabel)\13\n\9infoListFrame:addChild(self.mOutputCaptionLabel); infoListFrame:addChild(self.mOutputLabel)\13\n\9infoListFrame:addChild(self.mConsumptionCaptionLabel); infoListFrame:addChild(self.mConsumptionLabel)\13\n\13\n\9self.mModeToggleButtonGroup = libGUI.newFrame(\"horizontal_layout\", 1)\13\n\9self.mModeToggleButtonGroup2 = libGUI.newFrame(\"horizontal_layout\", 1)\13\n\9local btnModeAuto = libGUI.newFrame(\"toggle_button\", \"AUTO\", \"center\")\13\n\9local btnModePWM = libGUI.newFrame(\"toggle_button\", \"PWM\", \"center\")\13\n\9local btnModeLoad = libGUI.newFrame(\"toggle_button\", \"LOAD\", \"center\")\13\n\9local btnModeGrid = libGUI.newFrame(\"toggle_button\", \"GRID\", \"center\")\13\n\13\n\9function btnModeAuto:onStateChange()\13\n\9\9reactor:setRegulationBehaviour(regulationState.AUTO)\13\n\9\9btnModePWM:onDraw(); btnModeLoad:onDraw(); btnModeGrid:onDraw()\13\n\9end\13\n\9function btnModeAuto:getToggleState()\13\n\9\9return reactor:getRegulationBehaviour() == regulationState.AUTO\13\n\9end\13\n\13\n\9function btnModePWM:onStateChange()\13\n\9\9reactor:setRegulationBehaviour(regulationState.PWM)\13\n\9\9btnModeAuto:onDraw(); btnModeLoad:onDraw(); btnModeGrid:onDraw()\13\n\9end\13\n\9function btnModePWM:getToggleState()\13\n\9\9return reactor:getRegulationBehaviour() == regulationState.PWM\13\n\9end\13\n\13\n\9function btnModeLoad:onStateChange()\13\n\9\9reactor:setRegulationBehaviour(regulationState.LOAD)\13\n\9\9btnModeAuto:onDraw(); btnModePWM:onDraw(); btnModeGrid:onDraw()\13\n\9end\13\n\9function btnModeLoad:getToggleState()\13\n\9\9return reactor:getRegulationBehaviour() == regulationState.LOAD\13\n\9end\13\n\13\n\9function btnModeGrid:onStateChange()\13\n\9\9reactor:setRegulationBehaviour(regulationState.GRID)\13\n\9\9btnModeAuto:onDraw(); btnModePWM:onDraw(); btnModeLoad:onDraw()\13\n\9end\13\n\9function btnModeGrid:getToggleState()\13\n\9\9return reactor:getRegulationBehaviour() == regulationState.GRID\13\n\9end\13\n\13\n\9self.mModeToggleButtonGroup:addChild(btnModeAuto)\13\n\9self.mModeToggleButtonGroup:addChild(btnModePWM)\13\n\9self.mModeToggleButtonGroup:addChild(btnModeLoad)\13\n\13\n\13\n\9self.mDisableButton = libGUI.newFrame(\"toggle_button\", \"ON/OFF\", \"center\")\13\n\9function self.mDisableButton:onStateChange()\13\n\9\9if not self:getToggleState() then\13\n\9\9\9reactor:setState(reactorState.ONLINE)\13\n\9\9\9reactor:setDisabled(false)\13\n\9\9else\13\n\9\9\9reactor:setState(reactorState.OFFLINE)\13\n\9\9\9reactor:setDisabled(true)\13\n\9\9end\13\n\9end\13\n\9function self.mDisableButton:getToggleState()\13\n\9\9return reactor:getState() ~= reactorState.OFFLINE and reactor:getState() ~= reactorState.ERROR\13\n\9end\13\n\13\n\9self.mModeToggleButtonGroup2:addChild(btnModeGrid)\13\n\9self.mModeToggleButtonGroup2:addChild(self.mDisableButton)\13\n\13\n\9self:addChild(self.mLoadBar)\13\n\9self:addChild(self.mStorageBar)\13\n\9self:addChild(infoListFrame)\13\n\9self:addChild(self.mModeToggleButtonGroup)\13\n\9self:addChild(self.mModeToggleButtonGroup2)\13\n\13\n\9self.mModeGridButton = btnModeGrid\13\n\9self.mReactor = reactor\13\n\9self.mInfoList = infoListFrame\13\nend\13\n\13\nfunction reactor_info_big:updateInfo()\13\n\9if self.mReactor:isConnected() then\13\n\9\9if self.mReactor:isActivelyCooled() then\13\n\9\9\9self.mAddressCaptionLabel:setText(\"Active Reactor\", false)\13\n\9\9\9self.mGenerationLabel:setText(stringutils.formatBt(self.mReactor:getOutputGenerationRate() / 1000), false)\13\n\9\9\9self.mOutputLabel:setText(stringutils.formatBt(self.mReactor:getOutputExtractionRate() / 1000), false)\13\n\9\9\9self.mModeLabel:setText(\"LOAD\", false)\13\n\13\n\9\9\9self.mStorageBar:setBarPalette({{math.huge, colors.white}})\13\n\13\n\9\9\9if self.mModeToggleButtonGroup:getParent() ~= nil then\13\n\9\9\9\9self:removeChild(self.mModeToggleButtonGroup)\13\n\9\9\9\9self.mModeToggleButtonGroup2:removeChild(self.mModeGridButton)\13\n\9\9\9end\13\n\9\9else\13\n\9\9\9self.mAddressCaptionLabel:setText(\"Passive Reactor\", false)\13\n\9\9\9self.mGenerationLabel:setText(stringutils.formatRFt(self.mReactor:getOutputGenerationRate()), false)\13\n\9\9\9self.mOutputLabel:setText(stringutils.formatRFt(self.mReactor:getOutputExtractionRate()), false)\13\n\9\9\9if self.mReactor:getRegulationBehaviour() == regulationState.AUTO then\13\n\9\9\9\9self.mModeLabel:setText(string.upper(self.mReactor.mRegulationState or \"---\") .. \" (\" .. regulationState.toString(self.mReactor:getRegulationBehaviour()) .. \")\", false)\13\n\9\9\9else\13\n\9\9\9\9self.mModeLabel:setText(string.upper(self.mReactor.mRegulationState or \"---\"), false)\13\n\9\9\9end\13\n\9\9\9self.mStorageBar:setBarPalette({{math.huge, colors.red}})\13\n\13\n\9\9\9if self.mModeToggleButtonGroup:getParent() == nil then\13\n\9\9\9\9self:addChild(self.mModeToggleButtonGroup)\13\n\9\9\9\9self.mModeToggleButtonGroup2:addChild(self.mModeGridButton)\13\n\9\9\9end\13\n\9\9end\13\n\13\n\9\9self.mStorageBar:setPercentage((self.mReactor:getOutputStored() + self.mReactor:getOutputGenerationRate()) / self.mReactor:getOutputStoredMax(), false)\13\n\9\9if self.mLoadBar:getPercentageOptimal() ~= self.mReactor:getOutputOpt() then\13\n\9\9\9self.mLoadBar:setPercentageOptimal(self.mReactor:getOutputOpt())\13\n\9\9end\13\n\9\9self.mLoadBar:setPercentage(self.mReactor:getOutput(), false)\13\n\9\9self.mStateLabel:setText(reactorState.toString(self.mReactor:getState()), false)\13\n\9\9self.mHeatLabel:setText(math.floor(self.mReactor:getFuelTemperature() + 0.5) .. \" Â°C\")\13\n\9\9self.mConsumptionLabel:setText(\13\n\9\9\9string.format(\"(%3d%%) %s\",\13\n\9\9\9\9math.floor(self.mReactor:getFuelLevel() * 100 + 0.5),\13\n\9\9\9\9stringutils.formatBt(self.mReactor:getFuelConsumedLastTick() / 1000, false)\13\n\9\9\9)\13\n\9\9)\13\n\9else\13\n\9\9self.mAddressCaptionLabel:setText(\"Reactor\", false)\13\n\9\9self.mStateLabel:setForeground(colors.red)\13\n\9\9self.mStateLabel:setText(\"DISCONNECTED\", false)\13\n\9\9self.mLoadBar:setPercentage(0, false)\13\n\9\9self.mStorageBar:setPercentage(0, false)\13\n\9\9self.mHeatLabel:setText(\"N/A\", false)\13\n\9\9self.mGenerationLabel:setText(\"N/A\", false)\13\n\9\9self.mOutputLabel:setText(\"N/A\", false)\13\n\9\9self.mConsumptionLabel:setText(\"N/A\", false)\13\n\9end\13\nend\13\n\13\nfunction reactor_info_big:onDraw(allowPartial)\13\n\9self:updateInfo()\13\n\9frame_base.onDraw(self, allowPartial)\13\nend\13\n\13\nfunction reactor_info_big:onResize()\13\n\9frame_base.onResize(self)\13\n\13\n\9local width, height = self:getSize()\13\n\13\n\9self.mLoadBar:setRegion(2, 2, 8, height - 2)\13\n\9self.mStorageBar:setRegion(12, 2, 8, height - 2)\13\n\9self.mInfoList:setRegion(24, 2, width - 25, #self.mInfoList.mChildren)\13\n\9self.mModeToggleButtonGroup:setRegion(24, height - 7, width - 24, 3)\13\n\9self.mModeToggleButtonGroup2:setRegion(24, height - 3, width - 24, 3)\13\nend\13\n\13\nreturn reactor_info_big\13\n"},name="br_grid_control_gui",links={},version="4.28",depends={"oop","br_grid_control","libGUI","stringutils"}}