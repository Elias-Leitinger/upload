{name="libGUI",version="0.77",links={},files={["/usr/lib/libGUI/list.lua"]="local oop = require(\"oop\")\13\nlocal frame_base = require(\"libGUI/frame\")\13\n\13\nlocal list_frame = {}\13\noop.inherit(list_frame, frame_base)\13\n\13\nfunction list_frame:addChild(child)\13\n\9local nextPosition = 1\13\n\9for _, child in pairs(self.mChildren) do\13\n\9\9nextPosition = nextPosition + child:getHeight()\13\n\9end\13\n\13\n\9frame_base.addChild(self, child)\13\n\13\n\9child:setRegion(1, nextPosition, self:getWidth(), 1)\13\nend\13\n\13\nfunction list_frame:removeChild(child)\13\n\9frame_base.removeChild(self, child)\13\n\9self:repositionChildren()\13\nend\13\n\13\nfunction list_frame:repositionChildren()\13\n\9local i = 1\13\n\9for _, child in pairs(self.mChildren) do\13\n\9\9child:setPosition(1, i)\13\n\9\9i = i + child:getHeight()\13\n\9end\13\nend\13\n\13\nfunction list_frame:onResize()\13\n\9frame_base.onResize(self)\13\n\13\n\9for _, child in pairs(self.mChildren) do\13\n\9\9child:setWidth(self:getWidth())\13\n\9end\13\nend\13\n\13\nreturn list_frame\13\n",["/usr/lib/libGUI/label.lua"]="local oop = require(\"oop\")\13\nlocal frame_base = require(\"libGUI/frame\")\13\n\13\nlocal label_base = {\13\n\9mText = nil,\13\n\9mVerticalAlignment = \"middle\",\13\n\9mHorizontalAlignment = \"left\",\13\n\9mLabelOffsetX = 0,\13\n\9mLabelOffsetY = 0,\13\n\9mHasChanged = true\13\n}\13\noop.inherit(label_base, frame_base)\13\n\13\nfunction label_base:construct(label, alignment)\13\n\9frame_base.construct(self)\13\n\9if label ~= nil then\13\n\9\9self:setSize(string.len(label), 1)\13\n\9end\13\n\9if alignment ~= nil then\13\n\9\9self.mHorizontalAlignment = alignment\13\n\9end\13\n\9self:setText(label, false)\13\nend\13\n\13\nfunction label_base:setText(label, redraw)\13\n\9self.mHasChanged = (self.mText ~= label)\13\n\9self.mText = label\13\n\9if self.mHasChanged then\13\n\9\9self:recalculateOffset()\13\n\9end\13\n\9if redraw == nil or redraw then\13\n\9\9self:onDraw()\13\n\9end\13\nend\13\n\13\nfunction label_base:setTextAlignment(alignment)\13\n\9self.mHorizontalAlignment = alignment\13\n\9self:recalculateOffset()\13\nend\13\n\13\nfunction label_base:setVerticalAlignment(alignment)\13\n\9self.mVerticalAlignment = alignment\13\n\9self:recalculateOffset()\13\nend\13\n\13\nfunction label_base:onDraw(allowpartial)\13\n\9frame_base.onDraw(self, allowpartial)\13\n\13\n\9if not allowpartial or self.mHasChanged then\13\n\9\9local width, height = self:getSize()\13\n\13\n\9\9self:fill(1, 1, width, height, ' ')\13\n\9\9if self.mText ~= nil and string.len(self.mText) > 0 then\13\n\9\9\9self:set(1 + self.mLabelOffsetX, 1 + self.mLabelOffsetY, self.mText)\13\n\9\9end\13\n\9end\13\nend\13\n\13\nfunction label_base:recalculateOffset()\13\n\9local width, height = self:getSize()\13\n\13\n\9if self.mText ~= nil and string.len(self.mText) > 0 then\13\n\9\9if self.mHorizontalAlignment == \"left\" then\13\n\9\9\9self.mLabelOffsetX = 0\13\n\9\9elseif self.mHorizontalAlignment == \"center\" then\13\n\9\9\9self.mLabelOffsetX = math.floor( (width - string.len(self.mText)) / 2)\13\n\9\9elseif self.mHorizontalAlignment == \"right\" then\13\n\9\9\9self.mLabelOffsetX = width - string.len(self.mText)\13\n\9\9end\13\n\13\n\9\9if self.mVerticalAlignment == \"top\" then\13\n\9\9\9self.mLabelOffsetY = 0\13\n\9\9elseif self.mVerticalAlignment == \"middle\" then\13\n\9\9\9self.mLabelOffsetY = math.floor(height/2)\13\n\9\9elseif self.mVerticalAlignment == \"bottom\" then\13\n\9\9\9self.mLabelOffsetY = height - 1\13\n\9\9end\13\n\9end\13\n\9self.mHasChanged = true\13\nend\13\n\13\nfunction label_base:onResize()\13\n\9frame_base.onResize(self)\13\n\9self:recalculateOffset()\13\nend\13\n\13\nreturn label_base\13\n",["/usr/lib/libGUI/horizontal_layout.lua"]="local oop = require(\"oop\")\13\nlocal frame_base = require(\"libGUI/frame\")\13\n\13\nlocal horizontal_layout = {\13\n\9mPadding = 0\13\n}\13\noop.inherit(horizontal_layout, frame_base)\13\n\13\nfunction horizontal_layout:construct(padding)\13\n\9frame_base.construct(self)\13\n\9self.mPadding = padding or 0\13\nend\13\n\13\nfunction horizontal_layout:addChild(child)\13\n\9frame_base.addChild(self, child)\13\n\9self:resizeChildren()\13\nend\13\n\13\nfunction horizontal_layout:removeChild(child)\13\n\9frame_base.removeChild(self, child)\13\n\9self:resizeChildren()\13\nend\13\n\13\nfunction horizontal_layout:resizeChildren()\13\n\9local i = 0\13\n\9local width = math.floor( (self:getWidth() - self.mPadding) / #self.mChildren - self.mPadding)\13\n\9for _, child in pairs(self.mChildren) do\13\n\9\9child:setRegion(1 + self.mPadding + (width + self.mPadding) * i, 1, width, self:getHeight())\13\n\9\9i = i + 1\13\n\9end\13\nend\13\n\13\nfunction horizontal_layout:onResize()\13\n\9frame_base.onResize(self)\13\n\9self:resizeChildren()\13\nend\13\n\13\nreturn horizontal_layout",["/usr/lib/libGUI/frame.lua"]="local oop = require(\"oop\")\13\nlocal component = require(\"component\")\13\n\13\nlocal frame_base = {\13\n\9mGPU = nil,\13\n\9mParent = nil,\13\n\9mChildren = nil,\13\n\9mOffsetX = 0,\13\n\9mOffsetY = 0,\13\n\9mWidth = 0,\13\n\9mHeight = 0,\13\n\9mBackgroundColor = 0, mBackgroundIndex = false,\13\n\9mForegroundColor = 16777215, mForegroundIndex = false\13\n}\13\n\13\noop.make(frame_base)\13\nfunction frame_base:construct(parent)\13\n\9self.mParent = parent\13\n\9self.mChildren = {}\13\n\9if self.mParent and self:getGPU() then\13\n\9\9self.mGPU = self:getGPU()\13\n\9\9self.mBackgroundColor, self.mBackgroundIndex = self.mGPU.getBackground()\13\n\9\9self.mForegroundColor, self.mForegroundIndex = self.mGPU.getForeground()\13\n\9end\13\nend\13\n\13\nfunction frame_base:getGPU()\13\n\9if self.mParent then\13\n\9\9return self.mParent:getGPU()\13\n\9else\13\n\9\9return self.mGPU\13\n\9end\13\nend\13\n\13\nfunction frame_base:setGPU(gpu)\13\n\9self.mGPU = gpu\13\nend\13\n\13\nfunction frame_base:getParent()\13\n\9return self.mParent\13\nend\13\n\13\nfunction frame_base:setParent(parent)\13\n\9self.mParent = parent\13\n\9if parent ~= nil then\13\n\9\9self.mGPU = parent:getGPU()\13\n\9else\13\n\9\9self.mGPU = nil\13\n\9end\13\nend\13\n\13\nfunction frame_base:setPosition(x, y)\13\n\9self.mOffsetX = x-1\13\n\9self.mOffsetY = y-1\13\n\9self:onResize()\13\nend\13\n\13\nfunction frame_base:getPosition()\13\n\9return self.mOffsetX+1, self.mOffsetY+1\13\nend\13\n\13\nfunction frame_base:setSize(width, height)\13\n\9self.mWidth = width\13\n\9self.mHeight = height\13\n\9self:onResize()\13\nend\13\n\13\nfunction frame_base:getSize()\13\n\9return self.mWidth, self.mHeight\13\nend\13\n\13\nfunction frame_base:setRegion(x, y, width, height)\13\n\9self.mOffsetX = x-1\13\n\9self.mOffsetY = y-1\13\n\9self.mWidth = width\13\n\9self.mHeight = height\13\n\13\n\9self:onResize()\13\nend\13\n\13\nfunction frame_base:setWidth(width)\13\n\9self.mWidth = width\13\n\13\n\9self:onResize()\13\nend\13\n\13\nfunction frame_base:getWidth()\13\n\9return self.mWidth\13\nend\13\n\13\nfunction frame_base:setHeight(height)\13\n\9self.mHeight = height\13\n\13\n\9self:onResize()\13\nend\13\n\13\nfunction frame_base:getHeight()\13\n\9return self.mHeight\13\nend\13\n\13\nfunction frame_base:addChild(child)\13\n\9if child:getParent() then\13\n\9\9if child:getParent() == self then\13\n\9\9\9return\13\n\9\9end\13\n\9\9child:getParent():removeChild(child)\13\n\9end\13\n\9table.insert(self.mChildren, child)\13\n\9child:setParent(self)\13\nend\13\n\13\nfunction frame_base:removeChild(child)\13\n\9if not (child:getParent() == self) then\13\n\9\9return\13\n\9end\13\n\13\n\9for idx,c in pairs(self.mChildren) do\13\n\9\9if c == child then\13\n\9\9\9table.remove(self.mChildren, idx)\13\n\9\9\9child:setParent(nil)\13\n\9\9\9break\13\n\9\9end\13\n\9end\13\nend\13\n\13\nfunction frame_base:onDraw(allowPartial)\13\n\9self.mGPU = self:getGPU()\13\n\13\n\9for _, child in pairs(self.mChildren) do\13\n\9\9child:onDraw(allowPartial)\13\n\9end\13\n\13\n\9local currentBackgroundColor, currentBackgroundIndex = self.mGPU.getBackground()\13\n\9local currentForegroundColor, currentForegroundIndex = self.mGPU.getForeground()\13\n\13\n\9if not ( currentBackgroundColor == self.mBackgroundColor and currentBackgroundIndex == self.mBackgroundIndex ) then\13\n\9\9self.mGPU.setBackground(self.mBackgroundColor, not not self.mBackgroundIndex)\13\n\9end\13\n\13\n\9if not ( currentForegroundColor == self.mForegroundColor and currentForegroundIndex == self.mForegroundIndex ) then\13\n\9\9self.mGPU.setForeground(self.mForegroundColor, not not self.mForegroundIndex)\13\n\9end\13\nend\13\n\13\nfunction frame_base:onTouch(x, y, button, playerName)\13\n\9for _, child in pairs(self.mChildren) do\13\n\9\9local childX, childY = child:getPosition()\13\n\9\9local childW, childH = child:getSize()\13\n\13\n\9\9if x >= childX and x < childX+childW and y >= childY and y < childY+childH then\13\n\9\9\9child:onTouch(x - childX + 1, y - childY + 1, button, playerName)\13\n\9\9end\13\n\9end\13\nend\13\n\13\nfunction frame_base:onResize()\13\nend\13\n\13\n-- Wrappers\13\n\13\nfunction frame_base:getBackground()\13\n\9return self.mBackgroundColor, self.mBackgroundIndex\13\nend\13\n\13\nfunction frame_base:setBackground(color, isPaletteColor)\13\n\9if not (self.mBackgroundColor == color and self.mBackgroundIndex == isPaletteColor) then\13\n\9\9self.mBackgroundColor = color\13\n\9\9self.mBackgroundIndex = isPaletteColor\13\n\9\9if self.mGPU ~= nil then\13\n\9\9\9return self.mGPU.setBackground(color, not not isPaletteColor)\13\n\9\9else\13\n\9\9\9return nil\13\n\9\9end\13\n\9else\13\n\9\9return self.mGPU.getBackground()\13\n\9end\13\nend\13\n\13\nfunction frame_base:getForeground()\13\n\9return self.mForegroundColor, self.mForegroundIndex\13\nend\13\n\13\nfunction frame_base:setForeground(color, isPaletteColor)\13\n\9if not (self.mForegroundColor == color and self.mForegroundIndex == isPaletteColor) then\13\n\9\9self.mForegroundColor = color\13\n\9\9self.mForegroundIndex = isPaletteColor\13\n\9\9if self.mGPU ~= nil then\13\n\9\9\9return self.mGPU.setForeground(color, not not isPaletteColor)\13\n\9\9else\13\n\9\9\9return nil\13\n\9\9end\13\n\9else\13\n\9\9return self.mGPU.getForeground()\13\n\9end\13\nend\13\n\13\nfunction frame_base:get(x, y)\13\n\9if self.mWidth < x or self.mHeight < y then\13\n\9\9return nil\13\n\9elseif self.mParent then\13\n\9\9return self.mParent:get(self.mOffsetX + x, self.mOffsetY + y)\13\n\9else\13\n\9\9return self.mGPU.get(self.mOffsetX + x, self.mOffsetY + y)\13\n\9end\13\nend\13\n\13\nfunction frame_base:set(x, y, value, vertical)\13\n\9if not vertical then\13\n\9\9value = string.sub(value, 1, self.mWidth - x + 1)\13\n\9else\13\n\9\9value = string.sub(value, 1, self.mHeight - y + 1)\13\n\9end\13\n\13\n\9if self.mWidth < x or self.mHeight < y then\13\n\9\9return false\13\n\9elseif self.mParent then\13\n\9\9return self.mParent:set(self.mOffsetX + x, self.mOffsetY + y, value, vertical)\13\n\9else\13\n\9\9return self.mGPU.set(self.mOffsetX + x, self.mOffsetY + y, value, not not vertical)\13\n\9end\13\nend\13\n\13\nfunction frame_base:copy(x, y, width, height, tx, ty)\13\n\9if tx < 0 then\13\n\9\9x = x - tx\13\n\9\9width = width + tx\13\n\9end\13\n\9if ty < 0 then\13\n\9\9y = y - ty\13\n\9\9height = height + ty\13\n\9end\13\n\9if x < 0 then\13\n\9\9width = width + x\13\n\9\9x = 0\13\n\9end\13\n\9if y < 0 then\13\n\9\9height = height + y\13\n\9\9y = 0\13\n\9end\13\n\9width = math.min(width, self.mWidth)\13\n\9height = math.min(height, self.mHeight)\13\n\13\n\9if self.mWidth < x or self.mWidth < tx or self.mHeight < y or self.mHeight < ty then\13\n\9\9return false\13\n\9elseif self.mParent then\13\n\9\9return self.mParent:copy(self.mOffsetX + x, self.mOffsetY + y, width, height, self.mOffsetX + tx, self.mOffsetY + ty)\13\n\9else\13\n\9\9return self.mGPU.copy(self.mOffsetX + x, self.mOffsetY + y, width, height, self.mOffsetX + tx, self.mOffsetY + ty)\13\n\9end\13\nend\13\n\13\nfunction frame_base:fill(x, y, width, height, char)\13\n\9if x < 0 then\13\n\9\9width = width + x\13\n\9\9x = 0\13\n\9end\13\n\9if y < 0 then\13\n\9\9height = height + y\13\n\9\9y = 0\13\n\9end\13\n\9width = math.min(width, self.mWidth - x + 1)\13\n\9height = math.min(height, self.mHeight - y + 1)\13\n\13\n\9if self.mWidth < x or self.mHeight < y then\13\n\9\9return false\13\n\9elseif self.mParent then\13\n\9\9return self.mParent:fill(self.mOffsetX + x, self.mOffsetY + y, width, height, char)\13\n\9else\13\n\9\9return self.mGPU.fill(self.mOffsetX + x, self.mOffsetY + y, width, height, char)\13\n\9end\13\nend\13\n\13\nreturn frame_base\13\n",["/usr/lib/libGUI/tabframe.lua"]="local oop = require(\"oop\")\13\nlocal frame_base = require(\"libGUI/frame\")\13\nlocal colors = require(\"libGUI/colors\")\13\n\13\nlocal tabframe_base = {\13\n\9mClientFrame = nil,\13\n\9mItems = nil,\13\n\9mCaptionSpacing = 3,\13\n\9mCaptionPadding = 1,\13\n\9mCaptionUpdated = true\13\n}\13\noop.inherit(tabframe_base, frame_base)\13\n\13\nfunction tabframe_base:construct(parent)\13\n\9frame_base.construct(self, parent)\13\n\9self.mItems = {}\13\n\13\n\9self.mClientFrame = frame_base()\13\n\9frame_base.addChild(self, self.mClientFrame)\13\n\9self:setForeground(colors.black)\13\n\9self:setBackground(colors.lightGray)\13\nend\13\n\13\nfunction tabframe_base:addItem(caption, callback, frame)\13\n\9local item = {\13\n\9\9width = string.len(caption) + 2 * self.mCaptionPadding,\13\n\9\9caption = caption,\13\n\9\9callback = callback,\13\n\9\9frame = frame\13\n\9}\13\n\9table.insert(self.mItems, item)\13\n\9self.mCaptionUpdated = true\13\nend\13\n\13\nfunction tabframe_base:removeItem(caption)\13\n\9for i, item in pairs(self.mItems) do\13\n\9\9if item.caption == caption then\13\n\9\9\9table.remove(self.mItems, i)\13\n\9\9\9self.mCaptionUpdated = true\13\n\9\9\9break\13\n\9\9end\13\n\9end\13\nend\13\n\13\nfunction tabframe_base:activateItem(caption)\13\n\9for i, item in pairs(self.mItems) do\13\n\9\9if item.caption == caption then\13\n\9\9\9self:activateItemIndex(i)\13\n\9\9\9break\13\n\9\9end\13\n\9end\13\nend\13\n\13\nfunction tabframe_base:activateItemIndex(index)\13\n\9local item = self.mItems[index]\13\n\9if item.frame ~= nil and item.frame ~= self.mClientFrame then\13\n\9\9self:setFrameActive(item.frame)\13\n\9end\13\n\9if item.callback ~= nil then\13\n\9\9item.callback(self)\13\n\9end\13\n\9self.mClientFrame:onDraw()\13\nend\13\n\13\nfunction tabframe_base:setFrameActive(frame)\13\n\9local width, height = self:getSize()\13\n\9if frame ~= nil and frame ~= self.mClientFrame then\13\n\9\9frame_base.removeChild(self, self.mClientFrame)\13\n\9\9self.mClientFrame = frame\13\n\9\9frame_base.addChild(self, self.mClientFrame)\13\n\9\9self:setBackground(colors.black)\13\n\9\9self:fill(1, 2, width, height - 1, ' ')\13\n\9\9self:setBackground(colors.lightGray)\13\n\9\9self.mClientFrame:setRegion(1, 2, width, height - 1)\13\n\9end\13\n\9self.mClientFrame:onDraw()\13\nend\13\n\13\nfunction tabframe_base:drawTabItems()\13\n\9local width = self:getWidth()\13\n\9local offset = math.floor(self.mCaptionSpacing/2 + 0.5)\13\n\13\n\9local oldbg = self:setBackground(colors.gray)\13\n\9self:fill(1, 1, width, 1, ' ')\13\n\9self:setBackground(oldbg)\13\n\13\n\9for _, item in pairs(self.mItems) do\13\n\9\9local caption = item.caption; --string.sub(item.caption, 1, item.width)\13\n\9\9local x = math.floor( (item.width - string.len(caption)) / 2 + 0.5 )\13\n\9\9caption = string.rep(\" \", x) .. caption .. string.rep(\" \", item.width - x - string.len(caption))\13\n\9\9self:set(offset, 1, caption)\13\n\9\9offset = offset + item.width + self.mCaptionSpacing\13\n\9end\13\nend\13\n\13\nfunction tabframe_base:onResize()\13\n\9frame_base.onResize(self)\13\n\13\n\9local width, height = self:getSize()\13\n\13\n\9self.mClientFrame:setRegion(1, 2, width, height - 1)\13\nend\13\n\13\nfunction tabframe_base:onDraw(allowPartial)\13\n\9if not allowPartial then\13\n\9\9local width, height = self:getSize()\13\n\9\9self:setBackground(colors.black)\13\n\9\9self:fill(1, 2, width, height - 1, ' ')\13\n\9\9self:setBackground(colors.lightGray)\13\n\9end\13\n\13\n\9frame_base.onDraw(self, allowPartial)\13\n\9if not allowPartial or self.mCaptionUpdated then\13\n\9\9self:drawTabItems()\13\n\9\9self.mCaptionUpdated = false\13\n\9end\13\nend\13\n\13\nfunction tabframe_base:addChild(child)\13\n\9self.mClientFrame:addChild(child)\13\nend\13\n\13\nfunction tabframe_base:removeChild(child)\13\n\9self.mClientFrame:removeChild(child)\13\nend\13\n\13\nfunction tabframe_base:onTouch(x, y, button, playerName)\13\n\9frame_base.onTouch(self, x, y, button, playerName)\13\n\9if y ~= 1 then return; end\13\n\13\n\9local offset = math.floor(self.mCaptionSpacing/2 + 0.5)\13\n\13\n\9for i, item in pairs(self.mItems) do\13\n\9\9if x >= offset and x <= offset + item.width then\13\n\9\9\9self:activateItemIndex(i)\13\n\9\9\9break\13\n\9\9end\13\n\9\9offset = offset + item.width + self.mCaptionSpacing\13\n\9end\13\nend\13\n\13\nreturn tabframe_base\13\n",["/usr/lib/libGUI.lua"]="local component = require(\"component\")\13\nlocal computer = require(\"computer\")\13\nlocal event = require(\"event\")\13\nlocal oop = require(\"oop\")\13\n\13\nlocal frame_base = require(\"libGUI/frame\")\13\n\13\nlocal libGUI = {\13\n\9mGPU = nil,\13\n\9mRootFrame = nil,\13\n\9mRestoreInfo = {\13\n\9\9backgroundColor = nil,\13\n\9\9foregroundColor = nil,\13\n\9\9resolutionX = nil,\13\n\9\9resolutionY = nil\13\n\9},\13\n\9mTemplates = {},\13\n\9mOptimalResolutionFactorTiers = nil,\13\n\9mOptimalResolutionFactor = 1,\13\n\9mAspectLast = 1,\13\n\9mRedrawTimerId = nil\13\n}\13\n\13\nfunction libGUI.init()\13\n\9libGUI.mRootFrame = frame_base()\13\n\9libGUI.useSuitableGPU()\13\n\13\n\9event.listen(\"touch\", libGUI.onEventTouch)\13\n\9event.listen(\"screen_resized\", libGUI.onEventResize)\13\nend\13\n\13\nfunction libGUI.deinit()\13\n\9libGUI.reset()\13\n\13\n\9event.ignore(\"touch\", libGUI.onEventTouch)\13\n\9event.ignore(\"screen_resized\", libGUI.onEventResize)\13\nend\13\n\13\nfunction libGUI.restore()\13\n\9libGUI.mGPU.setBackground(libGUI.mRestoreInfo.backgroundColor)\13\n\9libGUI.mGPU.setForeground(libGUI.mRestoreInfo.foregroundColor)\13\n\9libGUI.mGPU.setResolution(libGUI.mRestoreInfo.resolutionX, libGUI.mRestoreInfo.resolutionY)\13\nend\13\n\13\nfunction libGUI.reset()\13\n\9if libGUI.mGPU ~= nil then\13\n\9\9libGUI.restore()\13\n\9end\13\n\9libGUI.mGPU = nil\13\n\9libGUI.mRootFrame = nil\13\n\9libGUI.setRedrawInterval(nil)\13\nend\13\n\13\nfunction libGUI.exit()\13\n\9libGUI.deinit()\13\n\9computer.pushSignal(\"libGUI_terminate\")\13\nend\13\n\13\nfunction libGUI.useSuitableGPU()\13\n\9local gpus = component.list(\"gpu\", true)\13\n\9local screens = component.list(\"screen\", true)\13\n\13\n\9local selected_gpu = nil\13\n\9local selected_depth = 0\13\n\9local selected_screen = nil\13\n\13\n\13\n\9for address, _ in pairs(gpus) do\13\n\9\9if address ~= component.gpu.address then\13\n\9\9\9local gpu = component.proxy(address)\13\n\9\9\9local depth = gpu.getDepth()\13\n\9\9\9if depth ~= nil and depth > selected_depth then\13\n\9\9\9\9selected_gpu = gpu\13\n\9\9\9\9selected_depth = depth\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\13\n\9for address, _ in pairs(screens) do\13\n\9\9if component.gpu.getScreen() ~= address then\13\n\9\9\9selected_screen = address\13\n\9\9end\13\n\9end\13\n\13\n\9if selected_gpu == nil or selected_screen == nil then\13\n\9\9libGUI.setGPU(component.gpu)\13\n\9else\13\n\9\9selected_gpu.bind(selected_screen)\13\n\9\9libGUI.setGPU(selected_gpu)\13\n\9end\13\nend\13\n\13\nfunction libGUI.setGPU(gpu)\13\n\9local width, height = gpu.getResolution()\13\n\9if libGUI.mGPU ~= nil then\13\n\9\9libGUI.restore()\13\n\9end\13\n\13\n\9libGUI.mGPU = gpu\13\n\13\n\9libGUI.mRestoreInfo.backgroundColor = gpu.setBackground(0)\13\n\9libGUI.mRestoreInfo.foregroundColor = gpu.setForeground(0xF0F0F0)\13\n\9libGUI.mRestoreInfo.resolutionX\9\9= width\13\n\9libGUI.mRestoreInfo.resolutionY\9\9= height\13\n\9gpu.fill(1, 1, width, height, ' ')\13\n\13\n\9libGUI.mRootFrame:setGPU(libGUI.mGPU)\13\n\9libGUI.mRootFrame:setSize(width, height)\13\nend\13\n\13\nfunction libGUI.setGPUByAddress(gpu_address)\13\n\9local gpu = component.proxy(gpu_address)\13\n\9if not gpu then\13\n\9\9io.stderr:write(\"GPU with address \\\"\" .. gpu_address .. \"\\\" not found.\")\13\n\9\9return false\13\n\9end\13\n\9libGUI.setGPU(gpu)\13\n\9return true\13\nend\13\n\13\nfunction libGUI.setRootFrame(rootFrame)\13\n\9libGUI.mRootFrame = rootFrame\13\n\13\n\9if libGUI.mGPU ~= nil then\13\n\9\9local width, height = libGUI.mGPU.getResolution()\13\n\13\n\9\9libGUI.mRootFrame:setGPU(libGUI.mGPU)\13\n\9\9libGUI.mRootFrame:setSize(width, height)\13\n\9end\13\nend\13\n\13\nfunction libGUI.setResolution(width, height)\13\n\9checkArg(1, width, \"number\")\13\n\9checkArg(2, height, \"number\")\13\n\13\n\9if libGUI.mGPU ~= nil then\13\n\9\9return libGUI.mGPU.setResolution(width, height)\13\n\9end\13\n\9return nil, nil\13\nend\13\n\13\nfunction libGUI.getResolution()\13\n\9if libGUI.mGPU ~= nil then\13\n\9\9return libGUI.mGPU.getResolution()\13\n\9end\13\n\9return nil, nil\13\nend\13\n\13\nfunction libGUI.getMaxResolution()\13\n\9if libGUI.mGPU ~= nil then\13\n\9\9return libGUI.mGPU.maxResolution()\13\n\9end\13\n\9return nil, nil\13\nend\13\n\13\nfunction libGUI.getResolutionTier()\13\n\9local maxWidth, _ = libGUI.getMaxResolution()\13\n\13\n\9if maxWidth == 50 then\13\n\9\9return 1\13\n\9elseif maxWidth == 80 then\13\n\9\9return 2\13\n\9elseif maxWidth == 160 then\13\n\9\9return 3\13\n\9else\13\n\9\9return nil\13\n\9end\13\nend\13\n\13\nfunction libGUI.setOptimalResolution(factor)\13\n\9if libGUI.mGPU == nil then\13\n\9\9return nil, nil\13\n\9elseif factor == nil or factor > 1 then\13\n\9\9factor = 1\13\n\9end\13\n\13\n\9local x, y = component.invoke(libGUI.mGPU.getScreen(), \"getAspectRatio\")\13\n\9local wMax, hMax = libGUI.mGPU.maxResolution()\13\n\9local pixelAspect = (x*14 - 4) / (y*7 - 2)\13\n\9local w1 = wMax * factor\13\n\9local h1 = w1 / pixelAspect\13\n\9local h2 = hMax * factor\13\n\9local w2 = h2 * pixelAspect\13\n\13\n\9libGUI.mOptimalResolutionFactor = factor\13\n\9if h1 <= hMax * factor then\13\n\9\9return libGUI.setResolution(w1, h1)\13\n\9else\13\n\9\9return libGUI.setResolution(w2, h2)\13\n\9end\13\nend\13\n\13\nfunction libGUI.setOptimalResolutionByTier(t3Factor, t2Factor, t1Factor)\13\n\9checkArg(1, t3Factor, \"number\")\13\n\9checkArg(2, t2Factor, \"number\", \"nil\")\13\n\9checkArg(3, t1Factor, \"number\", \"nil\")\13\n\13\n\9assert(t1Factor == nil or t2Factor ~= nil, \"You need to provide a t2 factor if you want to specify a t1 factor\")\13\n\13\n\9libGUI.mOptimalResolutionFactorTiers = { t1Factor or t2Factor or t3Factor, t2Factor or t3Factor, t3Factor }\13\n\13\n\9libGUI.setOptimalResolution(libGUI.getOptimalResolutionForTier(libGUI.getResolutionTier()))\13\nend\13\n\13\nfunction libGUI.getOptimalResolutionForTier(tier)\13\n\9checkArg(1, tier, \"number\", \"nil\")\13\n\13\n\9assert(tier == nil or (tier >= 1 and tier <= 3), \"Invalid resolution tier\")\13\n\13\n\9if libGUI.mOptimalResolutionFactorTiers == nil or tier == nil then\13\n\9\9return libGUI.mOptimalResolutionFactor\13\n\9end\13\n\13\n\9return libGUI.mOptimalResolutionFactorTiers[tier]\13\nend\13\n\13\nfunction libGUI.getRootFrame()\13\n\9return libGUI.mRootFrame\13\nend\13\n\13\n---\13\n\13\nfunction libGUI.redraw()\13\n\9if libGUI.mGPU ~= nil then\13\n\9\9local x, y = component.invoke(libGUI.mGPU.getScreen(), \"getAspectRatio\")\13\n\9\9if libGUI.mAspectLast ~= x/y then\13\n\9\9\9libGUI.setOptimalResolution(libGUI.getOptimalResolutionForTier(libGUI.getResolutionTier()))\13\n\9\9\9libGUI.mAspectLast = x/y\13\n\9\9end\13\n\9\9libGUI.mRootFrame:onDraw(true)\13\n\9end\13\nend\13\n\13\nfunction libGUI.setRedrawInterval(number)\13\n\9if libGUI.mRedrawTimerId ~= nil then\13\n\9\9event.cancel(libGUI.mRedrawTimerId)\13\n\9\9libGUI.mRedrawTimerId = nil\13\n\9end\13\n\9if number ~= nil then\13\n\9\9libGUI.mRedrawTimerId = event.timer(number, function()\13\n\9\9\9xpcall(libGUI.redraw, libGUI.makeErrorHandler(\"redraw\"))\13\n\9\9end\13\n\9\9, math.huge)\13\n\9end\13\nend\13\n\13\nfunction libGUI.runOrFork()\13\n\9local fork = not (libGUI.mGPU == component.gpu)\13\n\13\n\9if not fork then\13\n\9\9libGUI.run()\13\n\9end\13\nend\13\n\13\nfunction libGUI.run()\13\n\9while event.pull(math.huge, \"libGUI_terminate\") == nil do end\13\nend\13\n\13\n--- Factory\13\n\13\nfunction libGUI.registerFrameType(name, template)\13\n\9libGUI.mTemplates[name] = template\13\nend\13\n\13\nfunction libGUI.newFrame(name, ...)\13\n\9if libGUI.mTemplates[name] ~= nil then\13\n\9\9return libGUI.mTemplates[name](...)\13\n\9else\13\n\9\9libGUI.registerFrameType(name, require(\"libGUI/\" .. name))\13\n\9\9return libGUI.newFrame(name, ...)\13\n\9end\13\nend\13\n\13\n---\13\n\13\nfunction libGUI.onEventTouch(eventID, address, x, y, button, playerName)\13\n\9if libGUI.mGPU and libGUI.mGPU.getScreen() == address then\13\n\9\9xpcall(libGUI.mRootFrame.onTouch, libGUI.makeErrorHandler(\"touch\"), libGUI.mRootFrame, x, y, button, playerName)\13\n\9end\13\nend\13\n\13\nfunction libGUI.onEventResize(eventId, address, newWidth, newHeight)\13\n\9if libGUI.mGPU and libGUI.mGPU.getScreen() == address then\13\n\9\9xpcall(libGUI.mRootFrame.setSize, libGUI.makeErrorHandler(\"resize\"), libGUI.mRootFrame, newWidth, newHeight)\13\n\9\9xpcall(libGUI.mRootFrame.onDraw, libGUI.makeErrorHandler(\"resize\") , libGUI.mRootFrame, false)\13\n\9end\13\nend\13\n\13\n--\13\n\13\nfunction libGUI.makeErrorHandler(componentName)\13\n\9checkArg(1, componentName, \"string\")\13\n\13\n\9if debug ~= nil and debug.traceback ~= nil then\13\n\9\9return function(...)\13\n\9\9\9libGUI.exit()\13\n\9\9\9io.stderr:write(\"[libGUI \" .. componentName .. \"] \" .. debug.traceback( ... ) .. \"\\n\")\13\n\9\9end\13\n\9else\13\n\9\9return function(err)\13\n\9\9\9libGUI.exit()\13\n\9\9\9io.stderr:write(\"[libGUI \" .. componentName .. \"] \" .. tostring(err) .. \"\\n\")\13\n\9\9end\13\n\9end\13\nend\13\n\13\n--\13\n\13\nreturn libGUI --oop.exportFunctions(libGUI)\13\n",["/usr/lib/libGUI/colors.lua"]="return {\13\n\9white = 0xF0F0F0,\13\n\9orange = 0xF2B233,\13\n\9magenta = 0xE57FD8,\13\n\9lightBlue = 0x99B2F2,\13\n\9yellow = 0xDEDE6C,\13\n\9lime = 0x7FCC19,\13\n\9pink = 0xF2B2CC,\13\n\9gray = 0x4C4C4C,\13\n\9lightGray = 0x999999,\13\n\9cyan = 0x4C99B2,\13\n\9purple = 0xB266E5,\13\n\9blue = 0x3366CC,\13\n\9brown = 0x7F664C,\13\n\9green = 0x57A64E,\13\n\9red = 0xCC4C4C,\13\n\9black = 0,\13\n}",["/usr/lib/libGUI/test.lua"]="local oop = require(\"oop\")\13\nlocal frame_base = require(\"libGUI/frame\")\13\n\13\nlocal test_frame = {\13\n\9mTouched = false\13\n}\13\noop.inherit(test_frame, frame_base)\13\n\13\nfunction test_frame:onDraw()\13\n\9frame_base.onDraw(self)\13\n\13\n\9if not self.mTouched then\13\n\9\9self:set(1, 1, \"I'm at offsetY\" .. self.mOffsetY .. \"   \")\13\n\9else\13\n\9\9self:set(1, 1, \"I've been clicked!\")\13\n\9end\13\nend\13\n\13\nfunction test_frame:onTouch(x, y, button, playerName)\13\n\9frame_base.onTouch(self, x, y, button, playerName)\13\n\13\n\9self.mTouched = not self.mTouched\13\n\9self:onDraw()\13\nend\13\n\13\nreturn test_frame",["/usr/lib/libGUI/vertical_layout.lua"]="local oop = require(\"oop\")\13\nlocal frame_base = require(\"libGUI/frame\")\13\n\13\nlocal vertical_layout = {\13\n\9mPadding = 0\13\n}\13\noop.inherit(vertical_layout, frame_base)\13\n\13\nfunction vertical_layout:construct(padding)\13\n\9frame_base.construct(self)\13\n\9self.mPadding = padding or 0\13\nend\13\n\13\nfunction vertical_layout:addChild(child)\13\n\9frame_base.addChild(self, child)\13\n\9self:resizeChildren()\13\nend\13\n\13\nfunction vertical_layout:removeChild(child)\13\n\9frame_base.removeChild(self, child)\13\n\9self:resizeChildren()\13\nend\13\n\13\nfunction vertical_layout:resizeChildren()\13\n\9local i = 0\13\n\9local height = math.floor( (self:getHeight() - self.mPadding) / #self.mChildren - self.mPadding)\13\n\9for _, child in pairs(self.mChildren) do\13\n\9\9child:setRegion(1, 1 + self.mPadding + (height + self.mPadding) * i, self:getWidth(), height)\13\n\9\9i = i + 1\13\n\9end\13\nend\13\n\13\nfunction vertical_layout:onResize()\13\n\9frame_base.onResize(self)\13\n\9self:resizeChildren()\13\nend\13\n\13\nreturn vertical_layout",["/usr/lib/libGUI/window.lua"]="local oop = require(\"oop\")\13\nlocal frame_base = require(\"libGUI/frame\")\13\nlocal colors = require(\"libGUI/colors\")\13\n\13\nlocal window_base = {\13\n\9mTitle = nil,\13\n\9mClientFrame = nil\13\n}\13\noop.inherit(window_base, frame_base)\13\n\13\nfunction window_base:construct(parent)\13\n\9frame_base.construct(self, parent)\13\n\13\n\9self.mClientFrame = frame_base()\13\n\9frame_base.addChild(self, self.mClientFrame)\13\n\13\n\9self:setForeground(colors.white)\13\n\9self:setBackground(colors.blue)\13\nend\13\n\13\nfunction window_base:setTitle(title)\13\n\9self.mTitle = title\13\n\9self:drawTitle()\13\nend\13\n\13\nfunction window_base:drawTitle()\13\n\9local width = self:getWidth()\13\n\9local title = self.mTitle or \"\"\13\n\9local title_X = math.floor((width - string.len(title)) / 2 + 0.5)\13\n\13\n\9local output_str = string.rep(\" \", title_X) .. title .. string.rep(\" \", width - string.len(title) - title_X)\13\n\13\n\9self:set(1, 1, output_str)\13\nend\13\n\13\nfunction window_base:onResize()\13\n\9frame_base.onResize(self)\13\n\13\n\9local width, height = self:getSize()\13\n\13\n\9self.mClientFrame:setRegion(2, 3, width - 2, height - 3)\13\nend\13\n\13\nfunction window_base:onDraw()\13\n\9frame_base.onDraw(self)\13\n\9self:drawTitle()\13\nend\13\n\13\nfunction window_base:addChild(child)\13\n\9self.mClientFrame:addChild(child)\13\nend\13\n\13\nfunction window_base:removeChild(child)\13\n\9self.mClientFrame:removeChild(child)\13\nend\13\n\13\nreturn window_base\13\n",["/usr/lib/libGUI/toggle_button.lua"]="local oop = require(\"oop\")\13\nlocal label_base = require(\"libGUI/label\")\13\nlocal colors = require(\"libGUI/colors\")\13\n\13\nlocal toggle_button_base = {\13\n\9mInactiveBackground = colors.red,\13\n\9mInactiveForeground = colors.white,\13\n\9mActiveBackground = colors.green,\13\n\9mActiveForeground = colors.black,\13\n\13\n\9mToggleState = false\13\n}\13\noop.inherit(toggle_button_base, label_base)\13\n\13\nfunction toggle_button_base:construct(label, alignment)\13\n\9label_base.construct(self, label, alignment)\13\nend\13\n\13\nfunction toggle_button_base:setInactiveBackground(background)\13\n\9local oldBackground = self.mInactiveBackground\13\n\9self.mInactiveBackground = background\13\n\9return oldBackground\13\nend\13\n\13\nfunction toggle_button_base:getInactiveBackground()\13\n\9return self.mInactiveBackground\13\nend\13\n\13\nfunction toggle_button_base:setInactiveForeground(foreground)\13\n\9local oldForeground = self.mInactiveForeground\13\n\9self.mInactiveForeground = foreground\13\n\9return oldForeground\13\nend\13\n\13\nfunction toggle_button_base:getInactiveForeground()\13\n\9return self.mInactiveForeground\13\nend\13\n\13\nfunction toggle_button_base:setActiveBackground(background)\13\n\9local oldBackground = self.mActiveBackground\13\n\9self.mActiveBackground = background\13\n\9return oldBackground\13\nend\13\n\13\nfunction toggle_button_base:getActiveBackground()\13\n\9return self.mActiveBackground\13\nend\13\n\13\nfunction toggle_button_base:setActiveForeground(foreground)\13\n\9local oldForeground = self.mActiveForeground\13\n\9self.mActiveForeground = foreground\13\n\9return oldForeground\13\nend\13\n\13\nfunction toggle_button_base:getActiveForeground()\13\n\9return self.mActiveForeground\13\nend\13\n\13\nfunction toggle_button_base:getToggleState()\13\n\9return self.mToggleState\13\nend\13\n\13\nfunction toggle_button_base:onDraw(allowpartial)\13\n\9local toggleState = self:getToggleState()\13\n\9if toggleState then\13\n\9\9self:setBackground(self:getActiveBackground())\13\n\9\9self:setForeground(self:getActiveForeground())\13\n\9else\13\n\9\9self:setBackground(self:getInactiveBackground())\13\n\9\9self:setForeground(self:getInactiveForeground())\13\n\9end\13\n\13\n\9label_base.onDraw(self, allowpartial and toggleState == self.mToggleState)\13\n\9self.mToggleState = toggleState\13\nend\13\n\13\nfunction toggle_button_base:onTouch()\13\n\9label_base.onTouch(self)\13\n\13\n\9self.mToggleState = not self.mToggleState\13\n\13\n\9if self.onStateChange then\13\n\9\9self:onStateChange()\13\n\9end\13\n\13\n\9self:onDraw()\13\nend\13\n\13\nreturn toggle_button_base\13\n",["/usr/lib/libGUI/bar.lua"]="local oop = require(\"oop\")\13\nlocal frame_base = require(\"libGUI/frame\")\13\nlocal colors = require(\"libGUI/colors\")\13\n\13\nlocal bar_base = {\13\n\9mPercentage = 0,\13\n\9mBarPalette = nil,\13\n\9mBarBackgroundColor = colors.gray,\13\n\9mBorderColor = colors.lightGray,\13\n\9mBorderWidth = 1,\13\n\9mHasChanged = true\13\n}\13\noop.inherit(bar_base, frame_base)\13\n\13\nfunction bar_base:construct()\13\n\9frame_base.construct(self)\13\n\9self.mBarPalette = {{1, colors.green}}\13\nend\13\n\13\nfunction bar_base:setBarPalette(palette)\13\n\9self.mHasChanged = true\13\n\9self.mBarPalette = palette\13\nend\13\n\13\nfunction bar_base:setPercentage(percentage, redraw)\13\n\9self.mHasChanged = math.floor(8 * (math.max(self.mHeight, self.mWidth) - 2 * self.mBorderWidth) * math.min(1, math.max(0, self:getTranslatedPercentage(self.mPercentage))) + 0.5) ~= math.floor(8 * (math.max(self.mHeight, self.mWidth) - 2 * self.mBorderWidth) * math.min(1, math.max(0, self:getTranslatedPercentage(percentage))) + 0.5)\13\n\9self.mPercentage = percentage\13\n\9if redraw == nil or redraw then\13\n\9\9self:drawBar()\13\n\9end\13\nend\13\n\13\nfunction bar_base:setBorderWidth(width)\13\n\9self.mHasChanged = self.mBorderWidth ~= width\13\n\9self.mBorderWidth = width\13\nend\13\n\13\nfunction bar_base:getBarColor()\13\n\9local barColor = self.mBarPalette[#self.mBarPalette][2]\13\n\13\n\9for _, v in pairs(self.mBarPalette) do\13\n\9\9if v[1] >= self.mPercentage then\13\n\9\9\9barColor = v[2]\13\n\9\9\9break\13\n\9\9end\13\n\9end\13\n\13\n\9return barColor or colors.green\13\nend\13\n\13\nfunction bar_base:getTranslatedPercentage(percentage)\13\n\9return percentage or self.mPercentage\13\nend\13\n\13\nfunction bar_base:drawBarVertical()\13\n\9local barColor = self:getBarColor()\13\n\9local width, height = self:getSize()\13\n\9local barHeightReal = (height - 2 * self.mBorderWidth) * math.min(1, math.max(0, self:getTranslatedPercentage()))\13\n\9local barHeight = math.floor(barHeightReal)\13\n\9local barSubHeight = math.floor(8 * (barHeightReal - barHeight) + 0.5)\13\n\9local barSubBlocks = { '‚ñÅ', '‚ñÇ', '‚ñÉ', '‚ñÑ', '‚ñÖ', '‚ñÜ', '‚ñá'}\13\n\13\n\9if barSubHeight > 7 then\13\n\9\9barSubHeight = 0\13\n\9\9barHeight = barHeight + 1\13\n\9end\13\n\13\n\9self:setBackground(self.mBarBackgroundColor)\13\n\9self:fill(1 + self.mBorderWidth, 1 + self.mBorderWidth, width - 2 * self.mBorderWidth, height - 2 * self.mBorderWidth - barHeight, ' ')\13\n\9if barSubHeight > 0 then\13\n\9\9self:setForeground(barColor)\13\n\9\9self:fill(1 + self.mBorderWidth, height - barHeight - self.mBorderWidth, width - 2 * self.mBorderWidth, 1, barSubBlocks[barSubHeight])\13\n\9end\13\n\9self:setBackground(barColor)\13\n\9self:fill(1 + self.mBorderWidth, 1 + height - barHeight - self.mBorderWidth, width - 2 * self.mBorderWidth, barHeight, ' ')\13\nend\13\n\13\nfunction bar_base:drawBarHorizontal()\13\n\9local barColor = self:getBarColor()\13\n\9local width, height = self:getSize()\13\n\9local barWidthReal = (width - 2 * self.mBorderWidth) * math.min(1, math.max(0, self:getTranslatedPercentage()))\13\n\9local barWidth = math.floor(barWidthReal)\13\n\9local barSubWidth = math.floor(8 * (barWidthReal - barWidth) + 0.5)\13\n\9local barSubBlocks = { '‚ñè', '‚ñé', '‚ñç', '‚ñå', '‚ñã', '‚ñä', '‚ñâ'}\13\n\13\n\9if barSubWidth > 7 then\13\n\9\9barSubWidth = 0\13\n\9\9barWidth = barWidth + 1\13\n\9end\13\n\13\n\13\n\9self:setBackground(self.mBarBackgroundColor)\13\n\9self:fill(1 + self.mBorderWidth + barWidth, 1 + self.mBorderWidth, width - 2 * self.mBorderWidth - barWidth, height - 2 * self.mBorderWidth, ' ')\13\n\9if barSubWidth > 0 then\13\n\9\9self:setForeground(barColor)\13\n\9\9self:fill(1 + self.mBorderWidth + barWidth, 1 + self.mBorderWidth, 1, height - 2 * self.mBorderWidth, barSubBlocks[barSubWidth])\13\n\9end\13\n\9self:setBackground(barColor)\13\n\9self:fill(1 + self.mBorderWidth, 1 + self.mBorderWidth, barWidth, height - 2 * self.mBorderWidth, ' ')\13\nend\13\n\13\nfunction bar_base:drawBar()\13\n\9if self:getWidth() >= self:getHeight() then\13\n\9\9self:drawBarHorizontal()\13\n\9else\13\n\9\9self:drawBarVertical()\13\n\9end\13\nend\13\n\13\nfunction bar_base:onDraw(allowPartial)\13\n\9frame_base.onDraw(self, allowPartial)\13\n\13\n\9if not allowPartial or self.mHasChanged then\13\n\9\9local width, height = self:getSize()\13\n\9\9if self.mBorderWidth > 0 then\13\n\9\9\9self:setBackground(self.mBorderColor)\13\n\9\9\9self:fill(1, 1, width, height, ' ')\13\n\9\9end\13\n\13\n\9\9self:drawBar()\13\n\9\9self.mHasChanged = false\13\n\9end\13\nend\13\n\13\nreturn bar_base\13\n"},checksums={["/usr/lib/libGUI/colors.lua"]="ËóáIU“\26íßˇ—à2y£ÿ5‹`Ô˛wÉ\14P\1Cﬂroñv",["/usr/lib/libGUI/label.lua"]="µ\6®•`,÷øä8Ãﬂç•\16O\18?Ï˛TNÚt0Éh\24ÎSÊË",["/usr/lib/libGUI/horizontal_layout.lua"]=":L”Ÿz\0ñh„1{€BLè´\0O\13G\4\26≈u`!”4¥ÅÂ•",["/usr/lib/libGUI/test.lua"]="‚é»˘gK{~í∑!ÇÄÚA$∏p∂\20\6∑WsZìÉb“†N–"},depends={"oop"}}